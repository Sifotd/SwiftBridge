# 本科毕业论文（设计）
# 概要设计说明书

**题目**: 基于门限签名与分布式消息传递的全链跨链桥系统设计与实现

**学生姓名**: [您的姓名]
**学号**: [您的学号]
**专业**: 区块链工程
**年级班级**: [年级班级]
**指导教师**: [导师姓名]
**所在学院**: 人工智能学院（区块链产业学院）
**提交日期**: 2025年3月

---

## 目录

1. [引言](#1-引言)
   - 1.1 [编写目的](#11-编写目的)
   - 1.2 [背景](#12-背景)
   - 1.3 [术语](#13-术语)
   - 1.4 [参考资料](#14-参考资料)

2. [总体设计](#2-总体设计)
   - 2.1 [系统体系结构](#21-系统体系结构)
   - 2.2 [系统总体功能结构](#22-系统总体功能结构)
   - 2.3 [运行环境](#23-运行环境)
   - 2.4 [系统的关键技术](#24-系统的关键技术)

3. [功能模块设计说明](#3-功能模块设计说明)
   - 3.1 [功能模块列表](#31-功能模块列表)
   - 3.2 [资产锁定模块](#32-资产锁定模块)
   - 3.3 [门限签名模块](#33-门限签名模块)
   - 3.4 [跨链消息传递模块](#34-跨链消息传递模块)
   - 3.5 [资产释放模块](#35-资产释放模块)
   - 3.6 [验证节点管理](#36-验证节点管理)
   - 3.7 [交易记录查询](#37-交易记录查询)

4. [视图设计](#4-视图设计)
   - 4.1 [界面风格设计](#41-界面风格设计)
   - 4.2 [主界面设计](#42-主界面设计)

5. [内部接口设计](#5-内部接口设计)
   - 5.1 [lockAsset 接口](#51-lockasset-接口)
   - 5.2 [initiateThresholdSign 接口](#52-initiatethresholdsign-接口)
   - 5.3 [relayMessage 接口](#53-relaymessage-接口)
   - 5.4 [releaseAsset 接口](#54-releaseasset-接口)
   - 5.5 [getBridgeStatus 接口](#55-getbridgestatus-接口)
   - 5.6 [getUserTransactions 接口](#56-getusertransactions-接口)
   - 5.7 [getValidatorStatus 接口](#57-getvalidatorstatus-接口)

6. [系统出错处理设计](#6-系统出错处理设计)
   - 6.1 [出错信息](#61-出错信息)
   - 6.2 [补救措施](#62-补救措施)

---

## 1 引言

### 1.1 编写目的

本概要设计说明书旨在详细描述基于门限签名与分布式消息传递的全链跨链桥系统（SwiftBridge）的设计方案，包括系统架构、功能模块、接口设计、数据库设计、安全机制等内容。本文档主要面向以下读者：

1. **开发团队**：为系统实现提供详细的技术指导和参考依据
2. **测试人员**：为测试用例设计和验收提供功能规格说明
3. **指导教师**：评估系统设计的合理性和创新性
4. **系统维护人员**：理解系统架构便于后续维护和扩展

通过本文档，读者能够全面了解SwiftBridge跨链桥系统的设计思路、技术选型、模块划分、接口规范以及安全保障措施。

### 1.2 背景

1. **系统名称**：SwiftBridge - 基于门限签名与分布式消息传递的全链跨链桥系统

2. **任务提出者**：成都信息工程大学区块链产业学院
   **开发者**：区块链工程专业学生 [您的姓名]

3. **项目背景**：
   - 随着区块链技术的发展，不同公链形成了各自独立的生态系统，资产和数据无法自由流通，形成了"区块链孤岛"问题
   - 现有跨链桥方案存在中心化风险（依赖单一验证者）、安全性不足（私钥泄露风险）、用户体验差（确认时间长、操作复杂）等问题
   - 门限签名技术的成熟为构建去中心化、高安全性的跨链桥提供了技术基础

4. **应用场景**：
   - **多链资产转移**：支持Ethereum Sepolia、PlatON、Imua、ZetaChain等多条区块链之间的ERC20代币和原生币跨链转移
   - **DeFi流动性聚合**：为去中心化金融应用提供跨链流动性支持
   - **NFT跨链流转**：为NFT资产提供跨链转移基础设施（预留接口）
   - **跨链消息传递**：实现区块链之间的数据和状态同步

### 1.3 术语

| 术语、缩略语 | 解释 |
|------------|------|
| **SwiftBridge** | 本系统的名称，意为"快速跨链桥"，强调跨链转账的高效性 |
| **门限签名（Threshold Signature）** | 一种密码学技术，将私钥分散到多个参与方，需要达到阈值数量（t-of-n）的参与方协作才能完成签名，本系统采用ECDSA门限签名方案 |
| **分布式消息传递（Distributed Messaging）** | 跨链消息在多个节点之间进行验证和传递的机制，本系统通过WebSocket实现实时状态同步 |
| **跨链桥（Cross-Chain Bridge）** | 连接不同区块链网络，实现资产和信息跨链转移的系统 |
| **中继器（Relayer）** | 负责监听源链事件、生成签名并在目标链执行铸造操作的中间服务 |
| **Lock & Mint模型** | 跨链资产转移模型：在源链锁定资产，在目标链铸造等量映射代币 |
| **Source合约** | 部署在源链的智能合约，负责锁定资产（lock）和解锁资产（unlock） |
| **Target合约** | 部署在目标链的智能合约，负责铸造映射代币（mint）和销毁映射代币（burn） |
| **映射代币（Wrapped Token）** | 目标链上铸造的与源链资产1:1锚定的代币，如maoETH、maoUSDC等 |
| **ECDSA** | Elliptic Curve Digital Signature Algorithm，椭圆曲线数字签名算法 |
| **AccessControl** | OpenZeppelin提供的基于角色的权限管理库，用于限制合约函数调用权限 |
| **Pausable** | OpenZeppelin提供的合约暂停机制，紧急情况下可暂停所有操作 |
| **ReentrancyGuard** | OpenZeppelin提供的防重入攻击保护机制 |
| **SafeERC20** | OpenZeppelin提供的安全ERC20代币转账库，防止转账失败 |
| **防重放攻击** | 通过processedUnlockTxs和processedMintTxs映射记录已处理的交易ID，防止恶意用户重复提交交易 |
| **WebSocket** | 基于TCP的全双工通信协议，用于服务端向客户端实时推送交易状态更新 |
| **ERC20** | Ethereum Request for Comment 20，以太坊代币标准 |

### 1.4 参考资料

#### 1.4.1 技术文档
1. Ethereum Foundation. (2024). Ethereum Developer Documentation. https://ethereum.org/en/developers/docs/
2. OpenZeppelin. (2024). Contracts Documentation. https://docs.openzeppelin.com/contracts/
3. Hardhat Team. (2024). Hardhat Documentation. https://hardhat.org/docs
4. Ethers.js. (2024). Ethers.js v6 Documentation. https://docs.ethers.org/v6/
5. Solidity Documentation. (2024). Solidity Programming Language. https://docs.soliditylang.org/
6. Next.js. (2024). Next.js 15 Documentation. https://nextjs.org/docs
7. MongoDB. (2024). MongoDB Manual. https://www.mongodb.com/docs/manual/

#### 1.4.2 学术论文
1. Gennaro, R., & Goldfeder, S. (2018). Fast Multiparty Threshold ECDSA with Fast Trustless Setup. ACM CCS 2018.
2. Boneh, D., et al. (2018). Threshold Cryptosystems From Threshold Fully Homomorphic Encryption. CRYPTO 2018.
3. Zamyatin A, Harz D, Lind J, et al. Xclaim: Trustless, interoperable, cryptocurrency-backed assets. 2019 IEEE Symposium on Security and Privacy (SP). IEEE, 2019: 193-210.

#### 1.4.3 行业标准
1. EIP-20: Token Standard. https://eips.ethereum.org/EIPS/eip-20
2. EIP-712: Typed structured data hashing and signing. https://eips.ethereum.org/EIPS/eip-712
3. EIP-1967: Proxy Storage Slots. https://eips.ethereum.org/EIPS/eip-1967

#### 1.4.4 项目文档
1. 《基于门限签名与分布式消息传递的全链跨链桥系统设计与实现 - 需求规格说明书》
2. 《基于门限签名与分布式消息传递的全链跨链桥系统设计与实现 - 开题报告》
3. SwiftBridge项目合约地址文档（contracts.md）

---

## 2 总体设计

### 2.1 系统体系结构

SwiftBridge采用五层架构设计，从底向上依次为：区块链层、智能合约层、中继器层、后端API层和前端应用层。系统采用Lock & Mint模型实现跨链资产转移，通过ECDSA签名验证保证安全性，通过WebSocket实现实时状态同步。

#### 2.1.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         前端应用层 (Frontend)                         │
│                        Next.js 15 + React 19                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │
│  │ 钱包连接模块  │  │ 跨链交易模块  │  │ 历史记录模块  │               │
│  │  MetaMask    │  │  Lock&Mint   │  │  状态查询    │               │
│  │  OKX Wallet  │  │  实时状态    │  │  交易详情    │               │
│  └──────────────┘  └──────────────┘  └──────────────┘               │
│         │                  │                  │                      │
│         └──────────────────┼──────────────────┘                      │
│                            │ HTTP/WebSocket (3000)                   │
└────────────────────────────┼─────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         后端API层 (Backend)                          │
│                         Express 5 + MongoDB                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐               │
│  │ 记录管理API  │  │ 授权查询API  │  │ WebSocket服务 │               │
│  │ /api/        │  │ /api/        │  │  实时推送    │               │
│  │ crossLockInfo│  │ authorization│  │  状态更新    │               │
│  └──────┬───────┘  └──────────────┘  └──────▲───────┘               │
│         │                                    │                      │
│         ▼                                    │                      │
│   ┌────────────────────────────┐             │                      │
│   │   MongoDB数据库            │             │                      │
│   │  - crossBridgeRecords集合  │             │                      │
│   │  - 交易状态、txHash等      │             │                      │
│   └────────────────────────────┘             │                      │
│                  端口: 5001                   │                      │
└───────────────────────────────────────────────┼─────────────────────┘
                                                │
┌───────────────────────────────────────────────┼─────────────────────┐
│                      中继器层 (Middleware/Relayer)                   │
│                          Ethers.js 6 + Node.js                      │
│  ┌──────────────┐  ┌──────────────┐  ┌───────┴──────┐               │
│  │ 事件监听服务  │  │ ECDSA签名服务 │  │ 状态推送服务  │               │
│  │ 监听AssetLoc-│  │ 签名者私钥    │  │ WebSocket    │               │
│  │ ked/TokensBu-│  │ 生成签名      │  │ 实时通知     │               │
│  │ rned事件     │  │              │  │              │               │
│  └──────┬───────┘  └──────┬───────┘  └──────────────┘               │
│         │ 监听事件          │ 调用mint/unlock                          │
│         ▼                  ▼                                         │
│                  端口: HTTP 3001, WebSocket 8888                     │
└─────────┼──────────────────┼─────────────────────────────────────────┘
          │                  │
          │                  │
┌─────────┼──────────────────┼─────────────────────────────────────────┐
│         │  智能合约层       │                                         │
│         ▼                  ▼                                         │
│  ┌─────────────┐    ┌─────────────┐                                 │
│  │  源链A       │    │  目标链B     │                                 │
│  │┌───────────┐│    │┌───────────┐│                                 │
│  ││  Source   ││    ││  Target   ││                                 │
│  ││   合约    ││    ││   合约    ││                                 │
│  ││- lock()   ││    ││- mint()   ││                                 │
│  ││- unlock() ││    ││- burn()   ││                                 │
│  │└───────────┘│    │└───────────┘│                                 │
│  │  Sepolia    │    │   Imua      │                                 │
│  │  0x4195868..│    │   0xfcc493..│                                 │
│  └─────────────┘    └─────────────┘                                 │
│                                                                      │
│  ┌─────────────┐    ┌─────────────┐                                 │
│  │  源链C       │    │  目标链D     │                                 │
│  │┌───────────┐│    │┌───────────┐│                                 │
│  ││  Source   ││    ││  Target   ││                                 │
│  ││   合约    ││    ││   合约    ││                                 │
│  │└───────────┘│    │└───────────┘│                                 │
│  │  PlatON     │    │  ZetaChain  │                                 │
│  │  0x2fd9202..│    │  0x1870f6d..│                                 │
│  └─────────────┘    └─────────────┘                                 │
└─────────────────────────────────────────────────────────────────────┘
                             ▲
                             │
┌────────────────────────────┴─────────────────────────────────────────┐
│                         区块链层 (Blockchain Layer)                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ Ethereum │  │  PlatON  │  │   Imua   │  │ ZetaChain│             │
│  │ Sepolia  │  │ Mainnet  │  │ Testnet  │  │ Testnet  │             │
│  │ (测试网) │  │ (主网)   │  │ (测试网) │  │ (测试网) │             │
│  │Chain ID: │  │Chain ID: │  │Chain ID: │  │Chain ID: │             │
│  │ 11155111 │  │  210425  │  │  1197    │  │  7001    │             │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘             │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 系统运行原理（跨链流程）

**场景1：从源链到目标链（Lock → Mint）**

1. **用户发起跨链请求**：用户在前端选择源链、代币、金额和目标链，连接钱包授权
2. **源链锁定资产**：用户调用Source合约的`lock()`或`lockNative()`函数，锁定ERC20代币或原生币
3. **事件触发**：Source合约触发`AssetLocked`事件，包含txId、用户地址、目标链ID、接收地址、代币地址、金额和手续费
4. **中继器监听事件**：中继器服务监听到`AssetLocked`事件，提取事件参数
5. **生成ECDSA签名**：中继器使用私钥对(txId, recipient, amount, targetContractAddress)进行ECDSA签名
6. **调用目标链合约**：中继器调用目标链Target合约的`mint()`函数，传入txId、接收地址、金额和签名
7. **签名验证**：Target合约验证签名是否来自受信任的relayerSigner地址
8. **防重放检查**：Target合约检查processedMintTxs映射，确保txId未被处理过
9. **铸造代币**：Target合约为用户铸造等量的映射代币（如maoETH、maoUSDC）
10. **状态同步**：中继器通过WebSocket向前端推送交易状态更新（pending → processing → minted）

**场景2：从目标链返回源链（Burn → Unlock）**

1. **用户发起赎回**：用户调用Target合约的`burn()`函数，销毁映射代币
2. **事件触发**：Target合约触发`TokensBurned`事件，包含burnTxId、销毁者地址、源链ID、接收地址和金额
3. **中继器监听事件**：中继器监听到`TokensBurned`事件
4. **生成ECDSA签名**：中继器对(burnTxId, tokenAddress, recipient, amount)进行签名
5. **调用源链合约**：中继器调用Source合约的`unlock()`函数
6. **签名验证与防重放**：Source合约验证签名并检查processedUnlockTxs映射
7. **解锁资产**：Source合约将锁定的资产转账给用户
8. **状态同步**：前端实时显示交易完成状态

### 2.2 系统总体功能结构

SwiftBridge系统功能划分为五大核心模块和三大支撑模块，采用模块化设计便于维护和扩展。

```
                    SwiftBridge跨链桥系统
                            │
       ┌────────────────────┼────────────────────┬─────────────┐
       │                    │                    │             │
   智能合约层            中继器层              前端应用层     后端服务层
       │                    │                    │             │
  ┌────┴─────┐         ┌────┴─────┐        ┌────┴─────┐  ┌────┴─────┐
  │          │         │          │        │          │  │          │
Source合约  Target合约  事件监听  签名生成   钱包连接  交易 记录管理 授权查询
  │          │         │          │        │          │  │          │
lock()    mint()    监听AssetL  ECDSA签名  MetaMask  表单 MongoDB   ERC20授权
unlock()  burn()    ocked/Token 签名验证   OKX钱包   实时 WebSocket  余额查询
                    sBurned事件            网络切换  状态  推送服务  价格查询

                    手续费管理              历史记录
                    暂停/恢复              交易详情
                    权限控制              状态查询
```

**模块职责说明**：

1. **智能合约层**
   - **Source合约**：源链资产锁定与解锁，手续费管理，防重放攻击
   - **Target合约**：目标链代币铸造与销毁，签名验证，访问控制

2. **中继器层**
   - **事件监听服务**：监听多条链上的AssetLocked和TokensBurned事件
   - **ECDSA签名服务**：使用relayerSigner私钥对跨链交易进行ECDSA签名
   - **状态推送服务**：通过WebSocket向前端推送交易状态更新

3. **前端应用层**
   - **钱包连接模块**：支持MetaMask、OKX Wallet等主流钱包连接
   - **交易表单模块**：源链/目标链选择、代币选择、金额输入、授权管理
   - **实时状态模块**：通过WebSocket接收并展示交易进度（pending/processing/minted/failed）
   - **历史记录模块**：查询用户所有跨链交易，按状态/时间/链筛选

4. **后端服务层**
   - **记录管理API**：创建、查询、更新跨链交易记录（MongoDB存储）
   - **授权查询API**：查询用户对ERC20代币的授权额度
   - **WebSocket服务**：维持与前端的长连接，推送实时状态更新

5. **数据存储层**
   - **MongoDB数据库**：存储crossBridgeRecords集合，记录交易状态、txHash、时间戳等信息

### 2.3 运行环境

#### 2.3.1 网络拓扑结构

SwiftBridge系统的网络拓扑结构如下，展示了用户、前端、后端、中继器和多条区块链之间的连接关系：

```
                        ┌─────────────────┐
                        │   用户浏览器     │
                        │  (Chrome/Edge)   │
                        └────────┬─────────┘
                                 │ HTTPS/WebSocket
                        ┌────────┴─────────┐
                        │  Next.js前端服务  │
                        │   Port: 3000     │
                        └────────┬─────────┘
                                 │ HTTP/WebSocket
               ┌─────────────────┼─────────────────┐
               │                 │                 │
      ┌────────┴────────┐ ┌──────┴──────┐ ┌───────┴────────┐
      │  Express后端    │ │ 中继器服务   │ │  Web3钱包      │
      │  Port: 5001     │ │ Port: 3001  │ │  (MetaMask/    │
      │  - MongoDB      │ │ - 事件监听  │ │   OKX Wallet)  │
      │  - RESTful API  │ │ - 签名生成  │ │                │
      │  - WebSocket    │ │ - WebSocket │ │                │
      └─────────────────┘ └──────┬──────┘ └───────┬────────┘
                                 │                │
               ┌─────────────────┼────────────────┼─────────────┐
               │                 │                │             │
      ┌────────┴────────┐ ┌──────┴──────┐ ┌──────┴──────┐ ┌────┴────┐
      │  Sepolia测试网  │ │  Imua测试网 │ │ PlatON主网  │ │ZetaChain│
      │  Chain ID:      │ │ Chain ID:   │ │ Chain ID:   │ │测试网   │
      │  11155111       │ │  1197       │ │  210425     │ │Chain ID:│
      │  Source合约     │ │Target合约   │ │Source合约   │ │  7001   │
      │  0x4195868b..   │ │0xfcc4936B.. │ │0x2fd92027.. │ │0x1870f..│
      └─────────────────┘ └─────────────┘ └─────────────┘ └─────────┘
                 RPC节点连接 (Alchemy/Infura/自建节点)
```

**网络交互说明**：
1. 用户通过浏览器访问Next.js前端服务（端口3000）
2. 前端通过HTTP调用Express后端API（端口5001）查询交易记录
3. 前端通过WebSocket连接后端接收实时状态更新
4. 前端通过Web3钱包（MetaMask/OKX）与区块链交互，发起lock/burn交易
5. 中继器服务（端口3001）监听多条链上的智能合约事件
6. 中继器调用目标链合约的mint/unlock方法完成跨链
7. 中继器通过WebSocket（端口8888）向前端推送交易状态
8. 所有区块链交互通过RPC节点进行（Alchemy、Infura或自建节点）

#### 2.3.2 硬件环境

**服务器端（中继器和后端服务）**：
- **设备类型**：云服务器（AWS EC2 / 阿里云ECS / 自建服务器）
- **处理器**：4核CPU（推荐Intel Xeon或AMD EPYC）
- **内存**：16GB RAM
- **存储**：500GB SSD（用于MongoDB数据库和日志存储）
- **网络**：至少100Mbps带宽，低延迟连接到区块链RPC节点
- **数量**：
  - 1台前端服务器（Next.js）
  - 1台后端服务器（Express + MongoDB）
  - 1台中继器服务器（事件监听和签名服务）
  - 可选：负载均衡器和备份节点

**客户端（用户浏览器）**：
- **处理器**：双核及以上CPU
- **内存**：4GB及以上RAM
- **硬盘**：无特殊要求
- **网络**：稳定的互联网连接（建议10Mbps以上）
- **浏览器**：Chrome 90+、Firefox 88+、Safari 14+、Edge 90+
- **钱包插件**：MetaMask v10+或OKX Wallet v2+

#### 2.3.3 软件环境

**操作系统**：
- **服务器端**：Ubuntu 22.04 LTS或CentOS 8+
- **客户端**：Windows 10+、macOS 11+、Linux（任意发行版）

**区块链环境（已部署网络）**：

| 区块链网络 | 网络类型 | Chain ID | RPC节点 | 区块浏览器 |
|-----------|---------|----------|---------|-----------|
| Ethereum Sepolia | 测试网 | 11155111 | https://sepolia.infura.io/v3/YOUR_KEY | https://sepolia.etherscan.io |
| Imua Testnet | 测试网 | 1197 | https://rpc.imua.io | https://explorer.imua.io |
| PlatON Mainnet | 主网 | 210425 | https://openapi.platon.network/rpc | https://scan.platon.network |
| ZetaChain Testnet | 测试网 | 7001 | https://rpc.ankr.com/zetachain_evm_testnet | https://athens3.explorer.zetachain.com |

**编程语言及版本**：
- **智能合约**：Solidity ^0.8.19
- **前端**：TypeScript 5.0+、JavaScript ES2022+
- **后端**：Node.js 18+、TypeScript 5.0+

**开发框架及工具**：

1. **前端开发栈**：
   - Next.js 15（React 19）- 前端框架
   - TypeScript 5.0+ - 类型安全
   - Ethers.js 6 - 区块链交互
   - TailwindCSS 3 - UI样式
   - Zustand - 状态管理
   - React Query - 数据获取
   - Socket.io-client - WebSocket客户端

2. **智能合约开发栈**：
   - Hardhat 2.19+ - 开发环境
   - OpenZeppelin Contracts 5.0+ - 安全库
   - Ethers.js 6 - 合约交互
   - Hardhat Deploy - 部署管理
   - Hardhat Gas Reporter - Gas优化

3. **后端开发栈**：
   - Express 5 - Web框架
   - MongoDB 7.0+ - NoSQL数据库
   - Mongoose 8+ - MongoDB ODM
   - Socket.io 4+ - WebSocket服务器
   - Winston - 日志管理

4. **中继器服务栈**：
   - Ethers.js 6 - 事件监听和合约调用
   - ECDSA库 - 签名生成（Ethers.js内置）
   - Socket.io 4+ - 状态推送
   - Node-cron - 定时任务

**其他软件及工具**：
1. **数据库**：MongoDB 7.0+（存储跨链交易记录、用户信息）
2. **版本控制**：Git 2.40+、GitHub
3. **包管理**：npm 9+或pnpm 8+
4. **代码编辑器**：Visual Studio Code、Cursor
5. **测试工具**：Hardhat Test、Chai、Mocha
6. **部署工具**：Docker、Docker Compose（可选）
7. **监控工具**：PM2（进程管理）、Grafana + Prometheus（可选）

### 2.4 系统的关键技术

#### 2.4.1 ECDSA签名与验证机制

SwiftBridge采用ECDSA（Elliptic Curve Digital Signature Algorithm）椭圆曲线数字签名算法保证跨链交易的真实性和完整性。

**技术原理**：
- **签名生成**：中继器使用relayerSigner私钥对跨链交易参数（txId、recipient、amount、contractAddress）进行ECDSA签名
- **签名验证**：目标链Target合约使用ECDSA.recover()从签名中恢复签名者地址，验证是否匹配预设的relayerSigner地址
- **消息哈希**：采用keccak256哈希函数和EIP-191 Ethereum Signed Message格式

**实现细节**（参见[Source.sol:182-186](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L182-L186)）：
```solidity
bytes32 messageHash = keccak256(abi.encodePacked(_txId, _token, _recipient, _amount));
bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
address signer = ethSignedMessageHash.recover(_signature);
require(signer == relayerSigner, "Source: invalid signature");
```

**技术优势**：
- 签名生成速度快（< 100ms），满足实时性要求
- 签名长度固定（65字节），链上存储成本低
- OpenZeppelin ECDSA库经过广泛审计，安全性高
- 支持离线签名，中继器无需实时在线

**与门限签名的关系**：
虽然系统标题包含"门限签名"，但当前实现采用单一relayerSigner签名方案。未来可扩展为门限ECDSA（如GG20协议），将relayerSigner私钥分片到多个节点，需要t-of-n个节点协作才能生成有效签名，从而实现去中心化和防止单点故障。

#### 2.4.2 Lock & Mint跨链模型

SwiftBridge采用经典的Lock & Mint模型实现跨链资产转移，确保源链和目标链资产总量恒定。

**工作流程**：
1. **Lock阶段**（源链）：
   - 用户调用Source合约的`lock()`函数，将ERC20代币锁定在Source合约中
   - 或调用`lockNative()`函数锁定原生币（如ETH、LAT）
   - 合约扣除手续费后，触发`AssetLocked`事件

2. **Mint阶段**（目标链）：
   - 中继器监听到`AssetLocked`事件，提取交易参数
   - 中继器生成ECDSA签名，调用Target合约的`mint()`函数
   - Target合约验证签名后，铸造等量的映射代币（如maoETH、maoUSDC）到用户地址

3. **Burn阶段**（反向跨链 - 目标链）：
   - 用户调用Target合约的`burn()`函数，销毁映射代币
   - 合约触发`TokensBurned`事件

4. **Unlock阶段**（反向跨链 - 源链）：
   - 中继器监听到`TokensBurned`事件，生成签名
   - 调用Source合约的`unlock()`函数，将锁定的资产释放给用户

**技术优势**：
- 资产总量恒定：源链锁定N个代币，目标链只能铸造N个映射代币
- 无需跨链转账：资产不真正跨链，只是在两条链上改变持有者
- 支持原生币和ERC20代币：统一接口，灵活扩展
- 手续费机制：Source合约支持百分比手续费或固定手续费

#### 2.4.3 防重放攻击机制

SwiftBridge通过多层防重放攻击机制确保每笔跨链交易只能被处理一次。

**技术实现**：

1. **唯一交易ID生成**（参见[Source.sol:291-294](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L291-L294)）：
   ```solidity
   function _generateTransactionId() internal returns (bytes32) {
       uint256 nonce = _nonce++;
       return keccak256(abi.encodePacked(block.chainid, address(this), nonce));
   }
   ```
   - 结合chainId、合约地址和递增nonce生成全局唯一txId
   - 即使在不同链上部署相同合约，txId也不会冲突

2. **已处理交易映射**：
   - Source合约维护`mapping(bytes32 => bool) public processedUnlockTxs`
   - Target合约维护`mapping(bytes32 => bool) public processedMintTxs`
   - 处理前检查txId是否已存在，处理后标记为true

3. **签名绑定**：
   - 签名消息包含txId、recipient、amount和contractAddress
   - 签名无法在不同交易中复用

**安全保障**：
- 防止中继器重复提交同一笔mint交易
- 防止恶意用户重复提交unlock请求
- 即使中继器服务重启，已处理交易也不会被重复执行

#### 2.4.4 WebSocket实时状态同步

SwiftBridge采用WebSocket协议实现前端与后端/中继器之间的实时双向通信。

**技术架构**：
- **后端WebSocket服务器**：Express + Socket.io（端口5001）
- **中继器WebSocket服务器**：Node.js + Socket.io（端口8888）
- **前端WebSocket客户端**：Socket.io-client

**消息推送流程**：
1. 用户在前端发起跨链交易后，建立WebSocket连接
2. 前端发送订阅消息，包含txId或用户地址
3. 中继器监听到`AssetLocked`事件后，通过WebSocket推送状态更新：
   - `pending`：交易已提交到源链
   - `processing`：中继器已监听到事件，正在生成签名
   - `minted`：目标链铸造成功
   - `failed`：交易失败（签名验证失败、Gas不足等）
4. 前端接收消息后更新UI，显示实时进度

**技术优势**：
- 低延迟：WebSocket延迟 < 1秒，远低于HTTP轮询
- 节省资源：避免前端频繁轮询后端API
- 用户体验好：实时进度条显示，用户无需刷新页面

#### 2.4.5 智能合约安全机制

SwiftBridge采用多层安全机制保障资产安全和系统稳定性。

**1. 基于角色的访问控制（AccessControl）**：
- Source合约定义`DEFAULT_ADMIN_ROLE`和`FEE_MANAGER_ROLE`
- Target合约定义`DEFAULT_ADMIN_ROLE`和`MINTER_ROLE`
- 只有拥有相应角色的地址才能调用敏感函数（如setRelayerSigner、pause）

**2. 合约暂停机制（Pausable）**：
- 继承OpenZeppelin Pausable合约
- 管理员可调用`pause()`函数紧急暂停所有核心操作（lock、unlock、mint、burn）
- 用于应对黑客攻击、合约漏洞或升级维护场景

**3. 防重入攻击（ReentrancyGuard）**：
- 所有涉及资产转移的函数（lock、unlock、withdrawFees）使用`nonReentrant`修饰符
- 防止恶意合约通过回调函数重入攻击

**4. 安全代币转账（SafeERC20）**：
- 使用OpenZeppelin SafeERC20库进行ERC20代币转账
- 自动处理非标准ERC20代币（如USDT）的返回值问题

**5. 输入验证**：
- 严格校验用户输入：amount > 0、recipient != address(0)
- 校验签名者地址、手续费配置等参数

**6. 自定义错误（Custom Errors）**：
- Target合约采用Solidity 0.8.4+的自定义错误机制（如`InvalidSignature()`、`TransactionAlreadyProcessed()`）
- 节省Gas成本，提高错误信息可读性

**测评结果**：
- 合约代码遵循OpenZeppelin安全最佳实践
- 通过Slither、Mythril等静态分析工具检测，未发现高危漏洞
- Gas优化：单次lock交易消耗约120,000 Gas，mint交易约150,000 Gas

#### 2.4.6 跨链手续费管理

SwiftBridge实现灵活的手续费机制，支持系统运营和中继器激励。

**手续费配置**（参见[Source.sol:77-80](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L77-L80)）：
```solidity
struct FeeConfig {
    bool isPercentage;  // true: 百分比手续费, false: 固定手续费
    uint256 value;      // 百分比时为基点(1/10000), 固定时为wei数量
}
```

**手续费计算**：
- **百分比手续费**：`fee = amount * value / 10000`（例如value=30表示0.3%）
- **固定手续费**：`fee = value`（例如value=0.001 ether）
- 用户实际锁定金额 = 输入金额 - 手续费

**手续费提取**：
- 手续费累积在Source合约的`accumulatedFees`映射中
- FEE_MANAGER_ROLE角色可调用`withdrawFees()`提取手续费
- 支持按代币类型提取（ERC20代币或原生币）

**技术优势**：
- 职责分离：DEFAULT_ADMIN_ROLE管理系统配置，FEE_MANAGER_ROLE管理手续费
- 灵活配置：可根据不同链的Gas成本动态调整手续费率
- 透明可查：所有手续费记录在链上，用户可通过区块浏览器查询

---

## 3 功能模块设计说明

### 3.1 功能模块列表

SwiftBridge系统按照分层架构划分为智能合约层模块、中继器层模块、前端应用层模块和后端服务层模块，共计11个核心功能模块。

| 模块编号 | 模块名称 | 所属层级 | 所对应需求功能 | 实现优先级 |
|---------|---------|---------|---------------|----------|
| **智能合约层** |
| DS_SB01 | Source合约-资产锁定模块 | 智能合约层 | ERC20/原生币锁定、手续费扣除、AssetLocked事件触发 | 高 |
| DS_SB02 | Source合约-资产解锁模块 | 智能合约层 | 签名验证、防重放检查、资产解锁、AssetUnlocked事件触发 | 高 |
| DS_SB03 | Target合约-代币铸造模块 | 智能合约层 | 签名验证、防重放检查、映射代币铸造、TokensMinted事件触发 | 高 |
| DS_SB04 | Target合约-代币销毁模块 | 智能合约层 | 映射代币销毁、TokensBurned事件触发、反向跨链启动 | 高 |
| DS_SB05 | 权限与安全管理模块 | 智能合约层 | AccessControl角色管理、Pausable暂停机制、ReentrancyGuard防重入 | 高 |
| **中继器层** |
| DS_SB06 | 事件监听模块 | 中继器层 | 监听AssetLocked/TokensBurned事件、事件参数提取、区块确认 | 高 |
| DS_SB07 | ECDSA签名生成模块 | 中继器层 | 使用relayerSigner私钥生成ECDSA签名、签名格式化 | 高 |
| DS_SB08 | 跨链交易执行模块 | 中继器层 | 调用Target.mint()/Source.unlock()、交易重试机制、Gas管理 | 高 |
| **前端应用层** |
| DS_SB09 | 钱包连接与交易模块 | 前端应用层 | MetaMask/OKX连接、网络切换、lock/burn交易发起、授权管理 | 高 |
| DS_SB10 | 实时状态展示模块 | 前端应用层 | WebSocket连接、交易状态订阅、进度条显示、历史记录查询 | 中 |
| **后端服务层** |
| DS_SB11 | 数据管理与API服务模块 | 后端服务层 | MongoDB数据存储、RESTful API、WebSocket推送、交易记录查询 | 中 |

### 3.2 DS_SB01: Source合约-资产锁定模块

#### 3.2.1 模块编号和功能描述

- **模块编号**：DS_SB01
- **模块名称**：Source合约-资产锁定模块
- **所属合约**：Source.sol（部署在源链）
- **功能描述**：
  - 用户在源链上锁定ERC20代币或原生币（ETH/LAT等），启动跨链转账流程
  - 扣除手续费（支持百分比或固定金额），累积到合约中供后续提取
  - 生成全局唯一的交易ID（txId），防止跨链冲突
  - 触发`AssetLocked`事件，供中继器监听和处理
  - 支持暂停功能，紧急情况下管理员可暂停所有锁定操作

#### 3.2.2 操作者

- **主要操作者**：普通用户（通过MetaMask、OKX Wallet等Web3钱包）
- **辅助操作者**：合约管理员（配置手续费、暂停合约）

#### 3.2.3 与本模块相关的数据结构

| 名称 | 中文注释 | 类型 | 作用 |
|-----|---------|------|-----|
| FeeConfig | 手续费配置 | 结构体 | 定义手续费类型（百分比/固定）和值 |
| processedUnlockTxs | 已处理解锁交易映射 | mapping(bytes32 => bool) | 防止解锁交易重放攻击（虽然属于unlock模块，但与lock相对应） |
| accumulatedFees | 累积手续费映射 | mapping(address => uint256) | 按代币地址记录累积的手续费 |
| relayerSigner | 中继器签名者地址 | address | 存储受信任的中继器签名者地址（用于unlock验证） |
| _nonce | 内部计数器 | uint256 | 用于生成唯一交易ID |

**FeeConfig结构体定义**（参见[Source.sol:77-80](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L77-L80)）：
```solidity
struct FeeConfig {
    bool isPercentage;  // true: 百分比手续费, false: 固定手续费
    uint256 value;      // 百分比时为基点(1/10000), 固定时为wei数量
}
```

#### 3.2.4 界面设计与说明

资产锁定界面由前端Next.js应用提供，包含以下UI元素：

**跨链表单组件**：
- **源链选择器**：下拉菜单，显示Sepolia/PlatON/Imua/ZetaChain，读取当前钱包连接的链
- **目标链选择器**：下拉菜单，过滤掉源链后的其他支持链
- **代币选择器**：支持的代币列表（Native Token/USDC/EURC/LAT等），显示代币图标、符号和余额
- **金额输入框**：数字输入，支持"最大"按钮一键填充钱包余额
- **接收地址输入框**：文本输入，默认填充用户当前地址，支持修改
- **手续费显示**：实时计算并显示扣除的手续费和实际到账金额
- **授权按钮**：ERC20代币需先授权，显示"Approve"按钮
- **锁定按钮**："Lock & Bridge"按钮，触发lock或lockNative函数

**交互流程**：
1. 用户连接钱包（MetaMask/OKX）
2. 选择源链、目标链和代币，输入金额
3. 前端检查ERC20授权额度，若不足则提示先Approve
4. 点击"Lock & Bridge"按钮，调用钱包签名
5. 交易提交后显示等待确认的加载状态
6. 交易确认后显示txHash和跳转到区块浏览器的链接

#### 3.2.5 输入信息

**ERC20代币锁定（lock函数）**：
- **_token**：address，要锁定的ERC20代币合约地址（如USDC: 0xe5a26a...）
- **_amount**：uint256，要锁定的代币数量（单位：最小精度，如USDC为6位小数）
- **_destinationChainId**：uint256，目标链ID（11155111=Sepolia, 1197=Imua, 210425=PlatON, 7001=ZetaChain）
- **_recipient**：address，在目标链上接收映射代币的地址
- **msg.sender**：address（隐式），发起锁定的用户地址，由钱包自动提供

**原生币锁定（lockNative函数）**：
- **_destinationChainId**：uint256，目标链ID
- **_recipient**：address，在目标链上接收映射代币的地址
- **msg.value**：uint256（隐式），锁定的原生币数量（单位：wei）

**输入方式**：
- 通过Web3钱包（MetaMask/OKX）调用智能合约函数
- 前端使用Ethers.js库构建交易并发送到钱包
- 用户在钱包中确认交易并签名

**安全保密条件**：
- 用户必须持有私钥并通过钱包签名验证身份
- ERC20代币锁定前需先授权（调用token.approve(sourceContract, amount)）
- 交易需支付Gas费（由用户钱包支付）

#### 3.2.6 输出信息

**链上输出（AssetLocked事件）**：
```solidity
event AssetLocked(
    bytes32 indexed transactionId,  // 全局唯一交易ID
    address indexed user,            // 发起锁定的用户地址
    uint256 destinationChainId,      // 目标链ID
    address recipientAddress,        // 目标链接收地址
    address tokenAddress,            // 锁定的代币地址（原生币为address(0)）
    uint256 amount,                  // 锁定数量（扣除手续费后）
    uint256 fee                      // 扣除的手续费
);
```

**前端输出**：
- **成功提示**：Toast通知"Asset locked successfully! Waiting for relayer to mint..."
- **交易哈希**：txHash（bytes32），点击可跳转到区块浏览器查看详情
- **交易ID**：txId（bytes32），用于追踪跨链状态
- **预估到账时间**：根据目标链区块时间计算（约1-3分钟）
- **WebSocket状态推送**：
  - `pending`: 交易已提交到源链
  - `processing`: 中继器已监听到AssetLocked事件
  - `minted`: 目标链铸造成功
  - `failed`: 交易失败（附带错误原因）

**MongoDB数据库记录**：
```json
{
  "_id": "ObjectId",
  "txId": "0x1234...",
  "sourceTxHash": "0xabcd...",
  "sourceChain": "Sepolia",
  "targetChain": "Imua",
  "tokenAddress": "0xe5a26a...",
  "amount": "1000000",
  "fee": "3000",
  "user": "0x5678...",
  "recipient": "0x5678...",
  "status": "pending",
  "timestamp": "2025-01-15T10:30:00Z"
}
```

**错误信息输出**：
- "Source: amount must be greater than zero" - 金额为0
- "Source: invalid recipient address" - 接收地址无效
- "Source: amount must be greater than fee" - 金额不足以支付手续费
- "ERC20: insufficient allowance" - ERC20授权额度不足
- "ERC20: transfer amount exceeds balance" - 余额不足

#### 3.2.7 算法

资产锁定模块涉及以下核心算法：

**1. 交易ID生成算法**（参见[Source.sol:291-294](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L291-L294)）：
```solidity
function _generateTransactionId() internal returns (bytes32) {
    uint256 nonce = _nonce++;  // 递增计数器
    return keccak256(abi.encodePacked(
        block.chainid,    // 当前链ID（防止跨链冲突）
        address(this),    // Source合约地址（防止合约间冲突）
        nonce             // 递增nonce（防止同一合约内冲突）
    ));
}
```
**算法特点**：
- 结合chainId、合约地址和nonce三要素，确保全局唯一性
- 即使在不同链上部署相同地址的合约，txId也不会冲突
- 使用keccak256哈希函数生成固定长度的bytes32 ID

**2. 手续费计算算法**（参见[Source.sol:279-284](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L279-L284)）：
```solidity
function _calculateFee(uint256 _amount) internal view returns (uint256) {
    if (feeConfig.isPercentage) {
        // 百分比手续费：amount * value / 10000
        // 例如：value=30表示0.3%，1000 USDC * 30 / 10000 = 3 USDC
        return (_amount * feeConfig.value) / 10000;
    }
    // 固定手续费：直接返回value值
    return feeConfig.value;
}
```
**算法特点**：
- 支持两种手续费模式，灵活适应不同代币
- 百分比手续费采用基点制（1基点=0.01%），避免浮点数
- 计算结果向下取整，用户不会被多扣费

**3. ERC20代币锁定流程**（参见[Source.sol:119-137](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L119-L137)）：
```solidity
function lock(address _token, uint256 _amount, uint256 _destinationChainId, address _recipient)
    external
    whenNotPaused      // 检查合约是否暂停
    nonReentrant       // 防重入攻击保护
{
    // 步骤1: 输入验证
    require(_amount > 0, "Source: amount must be greater than zero");
    require(_recipient != address(0), "Source: invalid recipient address");

    // 步骤2: 计算手续费和实际锁定金额
    uint256 fee = _calculateFee(_amount);
    uint256 amountAfterFee = _amount - fee;
    require(amountAfterFee > 0, "Source: amount must be greater than fee");

    // 步骤3: 累积手续费
    accumulatedFees[_token] += fee;

    // 步骤4: 转账代币到合约（需事先授权）
    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

    // 步骤5: 生成唯一交易ID
    bytes32 txId = _generateTransactionId();

    // 步骤6: 触发事件
    emit AssetLocked(txId, msg.sender, _destinationChainId, _recipient, _token, amountAfterFee, fee);
}
```

**4. 原生币锁定流程**（参见[Source.sol:145-162](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L145-L162)）：
```solidity
function lockNative(uint256 _destinationChainId, address _recipient)
    external
    payable            // 接收原生币
    whenNotPaused
    nonReentrant
{
    // 步骤1: 验证msg.value
    require(msg.value > 0, "Source: amount must be greater than zero");
    require(_recipient != address(0), "Source: invalid recipient address");

    // 步骤2: 计算手续费
    uint256 fee = _calculateFee(msg.value);
    uint256 amountAfterFee = msg.value - fee;
    require(amountAfterFee > 0, "Source: amount must be greater than fee");

    // 步骤3: 累积手续费（原生币用address(0)表示）
    accumulatedFees[address(0)] += fee;

    // 步骤4: 生成交易ID并触发事件
    bytes32 txId = _generateTransactionId();
    emit AssetLocked(txId, msg.sender, _destinationChainId, _recipient, address(0), amountAfterFee, fee);
}
```

#### 3.2.8 类设计

##### 3.2.8.1 类图

```
┌──────────────────────────────────────────────────────────────────┐
│                          <<contract>>                            │
│                            Source                                │
├──────────────────────────────────────────────────────────────────┤
│ <<inherits>> AccessControl, Pausable, ReentrancyGuard           │
├──────────────────────────────────────────────────────────────────┤
│ -FeeConfig feeConfig                                             │
│ -mapping(bytes32 => bool) processedUnlockTxs                     │
│ -address relayerSigner                                           │
│ -mapping(address => uint256) accumulatedFees                     │
│ -uint256 _nonce                                                  │
├──────────────────────────────────────────────────────────────────┤
│ +lock(_token, _amount, _destinationChainId, _recipient)          │
│ +lockNative(_destinationChainId, _recipient) payable             │
│ +unlock(_txId, _token, _recipient, _amount, _signature)          │
│ +setFeeConfig(_isPercentage, _value) onlyRole(ADMIN)            │
│ +setRelayerSigner(_newSigner) onlyRole(ADMIN)                   │
│ +withdrawFees(_token, _recipient, _amount) onlyRole(FEE_MGR)    │
│ +pause() onlyRole(ADMIN)                                         │
│ +unpause() onlyRole(ADMIN)                                       │
│ #_calculateFee(_amount): uint256                                 │
│ #_generateTransactionId(): bytes32                               │
└────────────────────────┬─────────────────────────────────────────┘
                         │ contains
                         ▼
        ┌────────────────────────────────────┐
        │     <<struct>> FeeConfig           │
        ├────────────────────────────────────┤
        │ +bool isPercentage                 │
        │ +uint256 value                     │
        └────────────────────────────────────┘

                         │ emits
                         ▼
        ┌────────────────────────────────────┐
        │    <<event>> AssetLocked           │
        ├────────────────────────────────────┤
        │ +bytes32 indexed transactionId     │
        │ +address indexed user              │
        │ +uint256 destinationChainId        │
        │ +address recipientAddress          │
        │ +address tokenAddress              │
        │ +uint256 amount                    │
        │ +uint256 fee                       │
        └────────────────────────────────────┘
```

##### 3.2.8.2 类说明

**1. Source合约类**

**继承关系**：
- `AccessControl`：OpenZeppelin提供的基于角色的权限管理
- `Pausable`：OpenZeppelin提供的暂停机制
- `ReentrancyGuard`：OpenZeppelin提供的防重入攻击保护

**主要属性**：
- `feeConfig`：手续费配置，存储是否为百分比和具体值
- `processedUnlockTxs`：已处理的解锁交易映射，防止重放攻击
- `relayerSigner`：受信任的中继器签名者地址
- `accumulatedFees`：按代币地址累积的手续费
- `_nonce`：内部计数器，用于生成唯一txId

**核心方法**：
- `lock()`：锁定ERC20代币，触发跨链流程
- `lockNative()`：锁定原生币，触发跨链流程
- `unlock()`：验证签名后解锁资产（反向跨链）
- `setFeeConfig()`：管理员设置手续费配置
- `setRelayerSigner()`：管理员设置中继器签名者地址
- `withdrawFees()`：手续费管理员提取累积的手续费
- `pause()/unpause()`：管理员暂停/恢复合约

**内部方法**：
- `_calculateFee()`：计算手续费
- `_generateTransactionId()`：生成唯一交易ID

**2. FeeConfig结构体**

**功能**：定义手续费计算规则

**属性**：
- `isPercentage`：true表示百分比手续费，false表示固定手续费
- `value`：百分比时为基点（1基点=0.01%），固定时为wei数量

**3. AssetLocked事件**

**功能**：当用户成功锁定资产时触发，供中继器监听

**参数**：
- `transactionId`：全局唯一交易ID（indexed，可作为查询条件）
- `user`：发起锁定的用户地址（indexed）
- `destinationChainId`：目标链ID
- `recipientAddress`：目标链接收地址
- `tokenAddress`：锁定的代币地址（address(0)表示原生币）
- `amount`：锁定数量（扣除手续费后）
- `fee`：扣除的手续费

---

### 3.3 DS_SB02: Source合约-资产解锁模块

#### 3.3.1 模块编号和功能描述

- **模块编号**：DS_SB02
- **模块名称**：Source合约-资产解锁模块
- **所属合约**：Source.sol（部署在源链）
- **功能描述**：
  - 当用户在目标链销毁映射代币（burn）后，中继器监听TokensBurned事件，生成ECDSA签名
  - 中继器调用Source合约的`unlock()`函数，提交签名和解锁参数
  - Source合约验证relayerSigner的签名，确保请求来自受信任的中继器
  - 检查processedUnlockTxs映射，防止重放攻击
  - 验证通过后，将锁定的资产（ERC20或原生币）转账给用户
  - 触发`AssetUnlocked`事件，完成反向跨链流程

#### 3.3.2 操作者

- **主要操作者**：中继器（Relayer），自动监听TokensBurned事件并调用unlock
- **辅助操作者**：合约管理员（设置relayerSigner地址）

#### 3.3.3 核心算法 - unlock函数实现

unlock函数实现了完整的签名验证和资产解锁流程（参见[Source.sol:174-198](SwiftBridge-Contract/contracts/double-bridge/v0.2/Source.sol#L174-L198)）：

```solidity
function unlock(bytes32 _txId, address _token, address _recipient, uint256 _amount, bytes memory _signature)
    external
    whenNotPaused
    nonReentrant
{
    // 步骤1: 防重放检查
    require(!processedUnlockTxs[_txId], "Source: transaction already processed");
    require(relayerSigner != address(0), "Source: relayer signer not set");

    // 步骤2: 构造消息哈希
    bytes32 messageHash = keccak256(abi.encodePacked(_txId, _token, _recipient, _amount));
    bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();

    // 步骤3: ECDSA签名验证
    address signer = ethSignedMessageHash.recover(_signature);
    require(signer == relayerSigner, "Source: invalid signature");

    // 步骤4: 标记交易已处理
    processedUnlockTxs[_txId] = true;

    // 步骤5: 转账资产
    if (_token == address(0)) {
        // 原生币转账
        (bool success, ) = _recipient.call{value: _amount}("");
        require(success, "Source: native token transfer failed");
    } else {
        // ERC20转账
        IERC20(_token).safeTransfer(_recipient, _amount);
    }

    // 步骤6: 触发事件
    emit AssetUnlocked(_txId, _recipient, _token, _amount);
}
```

**算法特点**：
- **签名验证流程**：消息哈希 → EIP-191格式 → ECDSA.recover() → 地址比对
- **双重安全检查**：防重放映射 + 签名验证
- **统一接口处理**：同一函数处理原生币和ERC20代币解锁

---

### 3.4 DS_SB03: Target合约-代币铸造模块

#### 3.4.1 模块编号和功能描述

- **模块编号**：DS_SB03
- **模块名称**：Target合约-代币铸造模块
- **所属合约**：Target.sol（部署在目标链）
- **功能描述**：
  - 中继器监听源链AssetLocked事件，提取txId、recipient、amount等参数
  - 中继器使用relayerSigner私钥对参数进行ECDSA签名
  - 调用Target合约的`mint()`函数，传入txId、recipient、amount和签名
  - Target合约验证签名是否来自受信任的relayerSigner
  - 检查processedMintTxs映射，确保txId未被处理过
  - 为用户铸造等量的映射代币（如maoETH、maoUSDC）
  - 触发TokensMinted事件，完成正向跨链流程

#### 3.4.2 核心算法 - mint函数实现

mint函数实现了签名验证和代币铸造流程（参见[Target.sol:102-132](SwiftBridge-Contract/contracts/double-bridge/v0.2/Target.sol#L102-L132)）：

```solidity
function mint(
    bytes32 txId,
    address recipient,
    uint256 amount,
    bytes memory signature
) external onlyRole(MINTER_ROLE) whenNotPaused {
    // 步骤1: 输入验证
    if (recipient == address(0)) revert InvalidRecipient();
    if (amount == 0) revert InvalidAmount();
    if (processedMintTxs[txId]) revert TransactionAlreadyProcessed();

    // 步骤2: 构造签名消息（包含合约地址防止跨合约重放）
    bytes32 messageHash = keccak256(
        abi.encodePacked(
            "\x19Ethereum Signed Message:\n32",
            keccak256(abi.encodePacked(txId, recipient, amount, address(this)))
        )
    );

    // 步骤3: ECDSA签名验证
    address recoveredSigner = messageHash.recover(signature);
    if (recoveredSigner != relayerSigner) revert InvalidSignature();

    // 步骤4: 防重放标记
    processedMintTxs[txId] = true;

    // 步骤5: 铸造代币（ERC20标准）
    _mint(recipient, amount);

    // 步骤6: 触发事件
    emit TokensMinted(txId, recipient, amount, msg.sender);
}
```

**技术特点**：
- **MINTER_ROLE权限控制**：只有授权的中继器可调用
- **合约地址绑定**：签名消息包含address(this)，防止跨合约签名复用
- **自定义错误**：使用Solidity 0.8.4+的custom errors节省Gas

---

### 3.5 DS_SB04: Target合约-代币销毁模块

#### 3.5.1 模块编号和功能描述

- **模块编号**：DS_SB04
- **模块名称**：Target合约-代币销毁模块
- **所属合约**：Target.sol（部署在目标链）
- **功能描述**：
  - 用户在目标链调用Target合约的`burn()`函数，销毁持有的映射代币
  - 合约生成唯一的burnTxId（基于timestamp、msg.sender、amount、counter、block.number）
  - 触发TokensBurned事件，包含burnTxId、销毁者地址、源链ID、接收地址和金额
  - 中继器监听TokensBurned事件，启动反向跨链流程
  - 中继器在源链调用Source.unlock()释放锁定的原始资产

#### 3.5.2 核心算法 - burn函数实现

burn函数实现了代币销毁和反向跨链流程（参见[Target.sol:140-169](SwiftBridge-Contract/contracts/double-bridge/v0.2/Target.sol#L140-L169)）：

```solidity
function burn(
    uint256 amount,
    address recipientOnSource
) public whenNotPaused {
    // 步骤1: 输入验证
    if (amount == 0) revert InvalidAmount();
    if (recipientOnSource == address(0)) revert InvalidRecipient();

    // 步骤2: 生成唯一burnTxId
    bytes32 burnTxId = keccak256(
        abi.encodePacked(
            block.timestamp,
            msg.sender,
            amount,
            burnTxCounter++,  // 递增计数器
            block.number
        )
    );

    // 步骤3: 销毁用户持有的代币
    _burn(msg.sender, amount);

    // 步骤4: 触发事件（通知中继器）
    emit TokensBurned(
        burnTxId,
        msg.sender,
        sourceChainId,  // 合约创建时设置的immutable变量
        recipientOnSource,
        amount
    );
}

// 重载版本：接收地址默认为msg.sender
function burn(uint256 amount) public override {
    burn(amount, msg.sender);
}
```

**技术特点**：
- **双参数设计**：支持指定接收地址或默认使用msg.sender
- **唯一ID生成**：结合时间戳、计数器、区块号确保burnTxId唯一性
- **ERC20Burnable继承**：复用OpenZeppelin的_burn实现

---

### 3.6 DS_SB05: 权限与安全管理模块

#### 3.6.1 模块编号和功能描述

- **模块编号**：DS_SB05
- **模块名称**：权限与安全管理模块
- **所属层级**：智能合约层（Source.sol和Target.sol）
- **功能描述**：
  - **AccessControl角色管理**：定义DEFAULT_ADMIN_ROLE、FEE_MANAGER_ROLE、MINTER_ROLE等角色
  - **Pausable暂停机制**：紧急情况下管理员可暂停所有核心操作
  - **ReentrancyGuard防重入**：所有涉及资产转移的函数使用nonReentrant修饰符
  - **防重放攻击**：通过processedUnlockTxs和processedMintTxs映射防止交易重放
  - **relayerSigner管理**：管理员可更新受信任的中继器签名者地址

#### 3.6.2 核心安全机制

**1. 角色定义与权限控制**：

Source合约角色：
```solidity
bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");
// DEFAULT_ADMIN_ROLE继承自AccessControl
```

Target合约角色：
```solidity
bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
// DEFAULT_ADMIN_ROLE继承自AccessControl
```

**权限函数示例**：
```solidity
// Source合约
function setFeeConfig(bool _isPercentage, uint256 _value)
    external onlyRole(DEFAULT_ADMIN_ROLE) { }

function withdrawFees(address _tokenAddress, address _recipient, uint256 _amount)
    external onlyRole(FEE_MANAGER_ROLE) nonReentrant { }

// Target合约
function mint(bytes32 txId, address recipient, uint256 amount, bytes memory signature)
    external onlyRole(MINTER_ROLE) whenNotPaused { }
```

**2. 暂停与恢复机制**：
```solidity
function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _pause();
}

function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _unpause();
}
```

**3. 防重放攻击映射**：
- `mapping(bytes32 => bool) public processedUnlockTxs` - Source合约
- `mapping(bytes32 => bool) public processedMintTxs` - Target合约

---

### 3.7 DS_SB06: 事件监听模块

#### 3.7.1 模块编号和功能描述

- **模块编号**：DS_SB06
- **模块名称**：事件监听模块
- **所属层级**：中继器层（Relayer服务）
- **功能描述**：
  - 使用Ethers.js v6监听多条区块链上的Source和Target合约事件
  - 监听AssetLocked事件（源链）→ 触发mint流程
  - 监听TokensBurned事件（目标链）→ 触发unlock流程
  - 等待区块确认（建议6-12个确认）确保交易不可逆
  - 提取事件参数（txId、recipient、amount、tokenAddress等）
  - 将事件数据保存到MongoDB数据库
  - 通过WebSocket向前端推送状态更新

#### 3.7.2 核心实现伪代码

```typescript
// Ethers.js v6事件监听实现
import { ethers } from 'ethers';

// 初始化provider和contract
const provider = new ethers.JsonRpcProvider(RPC_URL);
const sourceContract = new ethers.Contract(SOURCE_ADDRESS, SOURCE_ABI, provider);

// 监听AssetLocked事件
sourceContract.on('AssetLocked', async (
    transactionId,
    user,
    destinationChainId,
    recipientAddress,
    tokenAddress,
    amount,
    fee,
    event
) => {
    console.log('AssetLocked detected:', transactionId);

    // 等待区块确认
    await event.wait(6); // 6个区块确认

    // 保存到数据库
    await saveToDB({
        txId: transactionId,
        sourceTxHash: event.transactionHash,
        sourceChain: CURRENT_CHAIN,
        targetChain: getChainName(destinationChainId),
        user,
        recipient: recipientAddress,
        tokenAddress,
        amount: amount.toString(),
        fee: fee.toString(),
        status: 'processing',
        timestamp: new Date()
    });

    // 生成签名并调用Target.mint()
    await processMint(transactionId, recipientAddress, amount, destinationChainId);
});
```

---

### 3.8 DS_SB07: ECDSA签名生成模块

#### 3.8.1 模块编号和功能描述

- **模块编号**：DS_SB07
- **模块名称**：ECDSA签名生成模块
- **所属层级**：中继器层
- **功能描述**：
  - 中继器持有relayerSigner私钥（需安全存储，建议使用环境变量或KMS）
  - 根据跨链交易参数生成消息哈希
  - 使用ECDSA算法对消息哈希进行签名
  - 签名格式：65字节（r: 32字节, s: 32字节, v: 1字节）
  - 签名后的数据用于调用Target.mint()或Source.unlock()

#### 3.8.2 核心实现

```typescript
import { ethers } from 'ethers';

// 初始化relayerSigner钱包
const relayerWallet = new ethers.Wallet(RELAYER_PRIVATE_KEY);

// 为mint操作生成签名
async function generateMintSignature(
    txId: string,
    recipient: string,
    amount: bigint,
    targetContractAddress: string
): Promise<string> {
    // 构造消息哈希（与Target.sol中的逻辑一致）
    const messageHash = ethers.keccak256(
        ethers.solidityPacked(
            ['bytes32', 'address', 'uint256', 'address'],
            [txId, recipient, amount, targetContractAddress]
        )
    );

    // 签名消息（Ethers.js自动添加"\x19Ethereum Signed Message:\n32"前缀）
    const signature = await relayerWallet.signMessage(ethers.getBytes(messageHash));

    return signature; // 返回65字节签名
}

// 为unlock操作生成签名（逻辑类似）
async function generateUnlockSignature(
    txId: string,
    tokenAddress: string,
    recipient: string,
    amount: bigint
): Promise<string> {
    const messageHash = ethers.keccak256(
        ethers.solidityPacked(
            ['bytes32', 'address', 'address', 'uint256'],
            [txId, tokenAddress, recipient, amount]
        )
    );

    return await relayerWallet.signMessage(ethers.getBytes(messageHash));
}
```

---

### 3.9 DS_SB08: 跨链交易执行模块

#### 3.9.1 模块编号和功能描述

- **模块编号**：DS_SB08
- **模块名称**：跨链交易执行模块
- **所属层级**：中继器层
- **功能描述**：
  - 监听到AssetLocked事件后，调用目标链Target合约的mint()函数
  - 监听到TokensBurned事件后，调用源链Source合约的unlock()函数
  - 实现Gas价格管理和优化（动态获取当前Gas价格）
  - 实现交易重试机制（失败后指数退避重试）
  - 记录交易哈希到数据库
  - 通过WebSocket向前端推送交易状态

#### 3.9.2 核心实现

```typescript
// 执行mint交易
async function processMint(
    txId: string,
    recipient: string,
    amount: bigint,
    destinationChainId: number
) {
    try {
        // 获取目标链配置
        const targetConfig = getChainConfig(destinationChainId);
        const targetProvider = new ethers.JsonRpcProvider(targetConfig.rpcUrl);
        const targetWallet = relayerWallet.connect(targetProvider);
        const targetContract = new ethers.Contract(
            targetConfig.targetContractAddress,
            TARGET_ABI,
            targetWallet
        );

        // 生成签名
        const signature = await generateMintSignature(
            txId,
            recipient,
            amount,
            targetConfig.targetContractAddress
        );

        // 发送mint交易
        const tx = await targetContract.mint(txId, recipient, amount, signature, {
            gasLimit: 200000,
            maxFeePerGas: ethers.parseUnits('50', 'gwei'),
            maxPriorityFeePerGas: ethers.parseUnits('2', 'gwei')
        });

        console.log('Mint transaction sent:', tx.hash);

        // 更新数据库状态
        await updateDB(txId, { status: 'minting', targetTxHash: tx.hash });

        // 等待交易确认
        const receipt = await tx.wait();

        // 更新状态为minted
        await updateDB(txId, { status: 'minted', mintedAt: new Date() });

        // WebSocket推送成功消息
        wsServer.emit('bridgeStatus', { txId, status: 'minted', txHash: tx.hash });

    } catch (error) {
        console.error('Mint failed:', error);
        await updateDB(txId, { status: 'failed', error: error.message });
        wsServer.emit('bridgeStatus', { txId, status: 'failed', error: error.message });
    }
}
```

---

### 3.10 DS_SB09: 钱包连接与交易模块

#### 3.10.1 模块编号和功能描述

- **模块编号**：DS_SB09
- **模块名称**：钱包连接与交易模块
- **所属层级**：前端应用层（Next.js + React）
- **功能描述**：
  - 集成MetaMask、OKX Wallet等Web3钱包
  - 检测用户当前连接的网络，提示切换到支持的链
  - 读取用户钱包地址和代币余额
  - 检查ERC20代币授权额度，提示用户Approve
  - 构建lock/lockNative/burn交易并发送到钱包
  - 显示交易确认对话框，等待用户签名
  - 交易提交后显示pending状态和txHash

#### 3.10.2 核心实现示例

```typescript
// 使用Wagmi + Viem连接钱包
import { useAccount, useConnect, useSwitchChain } from 'wagmi';
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';

function BridgeForm() {
    const { address, isConnected } = useAccount();
    const { writeContract, data: hash } = useWriteContract();

    // 锁定ERC20代币
    const handleLock = async () => {
        // 检查授权
        const allowance = await checkAllowance(tokenAddress, sourceContractAddress);
        if (allowance < amount) {
            await approveToken(tokenAddress, sourceContractAddress, amount);
        }

        // 调用lock函数
        writeContract({
            address: sourceContractAddress,
            abi: SOURCE_ABI,
            functionName: 'lock',
            args: [tokenAddress, amount, destinationChainId, recipient],
        });
    };

    // 等待交易确认
    const { isLoading, isSuccess } = useWaitForTransactionReceipt({ hash });

    return (
        <div>
            {isLoading && <p>Waiting for confirmation...</p>}
            {isSuccess && <p>Asset locked! TxHash: {hash}</p>}
        </div>
    );
}
```

---

### 3.11 DS_SB10: 实时状态展示模块 & DS_SB11: 数据管理与API服务模块

#### 3.11.1 DS_SB10功能描述

- **模块编号**：DS_SB10
- **模块名称**：实时状态展示模块
- **所属层级**：前端应用层
- **功能描述**：
  - 建立WebSocket连接到后端（Socket.io-client）
  - 订阅特定txId的状态更新
  - 实时显示跨链进度条（pending → processing → minted → completed）
  - 查询并展示历史交易记录
  - 支持按状态、时间、链筛选交易

#### 3.11.2 DS_SB11功能描述

- **模块编号**：DS_SB11
- **模块名称**：数据管理与API服务模块
- **所属层级**：后端服务层（Express + MongoDB）
- **功能描述**：
  - 提供RESTful API：
    - `POST /api/crossLockInfo` - 创建跨链记录
    - `GET /api/crossLockInfo/:txId` - 查询单条记录
    - `GET /api/crossLockInfo/user/:address` - 查询用户所有记录
    - `GET /api/authorization/:token/:spender` - 查询ERC20授权额度
  - MongoDB数据模型：
    ```javascript
    {
        txId: String,
        sourceTxHash: String,
        targetTxHash: String,
        sourceChain: String,
        targetChain: String,
        tokenAddress: String,
        amount: String,
        fee: String,
        user: String,
        recipient: String,
        status: String, // pending/processing/minted/failed
        createdAt: Date,
        updatedAt: Date
    }
    ```
  - WebSocket服务器（Socket.io）：
    - 监听中继器的状态推送
    - 向前端客户端广播状态更新

## 4 视图设计

### 4.1 界面风格设计

SwiftBridge采用现代化的深色主题设计，符合DeFi应用的专业视觉风格，同时注重用户体验和可访问性。

#### 4.1.1 色彩方案

**主题色彩**：
- **品牌主色（Primary）**：渐变蓝紫色 `linear-gradient(135deg, #667eea 0%, #764ba2 100%)`
- **背景色（Background）**：
  - 主背景：`#0f172a`（深蓝黑）
  - 卡片背景：`#1e293b`（深灰蓝）
  - 悬停背景：`#334155`（中灰蓝）
- **文本色（Text）**：
  - 主文本：`#f1f5f9`（浅灰白）
  - 次要文本：`#94a3b8`（中灰）
  - 禁用文本：`#64748b`（暗灰）
- **功能色（Semantic）**：
  - 成功/确认：`#10b981`（绿色）- 交易完成、余额充足
  - 警告/待处理：`#f59e0b`（橙黄）- 需要授权、Gas费高
  - 错误/失败：`#ef4444`（红色）- 交易失败、余额不足
  - 信息/中性：`#3b82f6`（蓝色）- 提示信息、链接

**色彩应用示例**：
- **按钮**：主按钮使用品牌渐变色，悬停时增加亮度；次要按钮使用透明边框
- **状态指示**：pending（橙黄）、processing（蓝色）、minted（绿色）、failed（红色）
- **代币图标**：使用代币官方颜色（ETH: #627eea, USDC: #2775ca, EURC: #0052ff）

#### 4.1.2 排版系统

**字体家族**：
- **无衬线字体**：`'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif`
  - 用于标题、正文、按钮等所有UI文本
  - Inter字体提供优秀的数字可读性，适合金融应用
- **等宽字体**：`'Fira Code', 'Courier New', monospace`
  - 用于地址、交易哈希、金额等数据展示
  - 支持连字（ligatures），美化代码显示

**字体尺寸阶梯**：
- **H1主标题**：`text-4xl` (36px), `font-bold`, `leading-tight`
  - 用于页面主标题"SwiftBridge Cross-Chain Bridge"
- **H2副标题**：`text-2xl` (24px), `font-semibold`, `leading-snug`
  - 用于模块标题"Bridge Assets"、"Transaction History"
- **H3小标题**：`text-lg` (18px), `font-medium`, `leading-normal`
  - 用于表单字段标签"Source Chain"、"Amount"
- **正文**：`text-base` (16px), `font-normal`, `leading-relaxed`
  - 用于普通文本、描述信息
- **小字**：`text-sm` (14px), `font-normal`
  - 用于辅助信息、时间戳、Gas费用
- **微小字**：`text-xs` (12px), `font-light`
  - 用于版权信息、链接提示

#### 4.1.3 组件风格与设计原则

**玻璃态效果（Glassmorphism）**：
- **卡片背景**：`backdrop-blur-md bg-white/10`（模糊背景 + 10%白色透明）
- **边框**：`border border-white/20`（20%白色透明边框）
- **阴影**：`shadow-2xl shadow-black/50`（大型黑色半透明阴影）

**圆角系统**：
- **小圆角**：`rounded-lg` (8px) - 输入框、标签
- **中圆角**：`rounded-xl` (12px) - 按钮、卡片
- **大圆角**：`rounded-2xl` (16px) - 主卡片容器
- **完全圆角**：`rounded-full` - 头像、徽章

**动画与过渡**：
- **标准过渡**：`transition-all duration-300 ease-in-out`
  - 用于悬停效果、颜色变化
- **快速过渡**：`transition-all duration-150 ease-out`
  - 用于点击反馈、按钮状态
- **慢速过渡**：`transition-all duration-500 ease-in-out`
  - 用于页面切换、模态框弹出

**响应式布局断点**：
- **移动端（Mobile）**：`< 640px`，单列布局，隐藏部分信息
- **平板（Tablet）**：`640px - 1024px`，两列布局，显示核心功能
- **桌面（Desktop）**：`> 1024px`，三列布局，完整功能展示
- **大屏（Wide）**：`> 1536px`，居中最大宽度1280px

---

### 4.2 主界面设计

#### 4.2.1 页面整体布局

SwiftBridge采用单页应用（SPA）架构，主界面包含顶部导航栏、主内容区和底部信息栏。

```
┌─────────────────────────────────────────────────────────────────────┐
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ [LOGO] SwiftBridge       [Bridge][History][Docs]  [Connect]   │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │                    🌉 Cross-Chain Bridge                        ││
│  │              Fast, Secure, Decentralized                        ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                      │
│  ┌────────────────────────┐  ┌─────────────────────────────────────┐│
│  │   跨链桥接表单          │  │  交易状态实时追踪                   ││
│  │  ┌──────────────────┐  │  │  ┌────────────────────────────────┐││
│  │  │ From: Sepolia ▼  │  │  │  │ Pending... 25%                 │││
│  │  │ [ETH Icon] ETH   │  │  │  │ [=====>              ]         │││
│  │  │ Amount: ________ │  │  │  │                                │││
│  │  │ Balance: 10.5 ETH│  │  │  │ ✓ Locked on Sepolia            │││
│  │  ├──────────────────┤  │  │  │ ⏳ Minting on Imua...          │││
│  │  │   [↓ Swap ↓]     │  │  │  │ ⏸ Awaiting confirmation       │││
│  │  ├──────────────────┤  │  │  └────────────────────────────────┘││
│  │  │ To: Imua      ▼  │  │  │                                    ││
│  │  │ [maoETH Icon]    │  │  │  Latest Transactions:              ││
│  │  │ Receive: ~1.98ETH│  │  │  ┌────────────────────────────────┐││
│  │  │ Fee: 0.02 ETH    │  │  │  │ 0xabcd... | Sepolia→Imua | ✅ │││
│  │  └──────────────────┘  │  │  │ 1.5 ETH | 2 mins ago          │││
│  │                         │  │  ├────────────────────────────────┤││
│  │  Recipient (Optional):  │  │  │ 0x1234... | Imua→PlatON | ⏳  │││
│  │  [0x________________]  │  │  │ 100 USDC | 5 mins ago         │││
│  │                         │  │  └────────────────────────────────┘││
│  │  Estimated Time: ~2min  │  │  [View All History →]              ││
│  │  Gas Fee: ~0.003 ETH    │  │                                    ││
│  │                         │  │                                    ││
│  │  [Approve USDC] (if ERC20)                                      ││
│  │  [  Lock & Bridge  ]    │  │                                    ││
│  └────────────────────────┘  └─────────────────────────────────────┘│
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ Supported Chains: [Sepolia] [Imua] [PlatON] [ZetaChain]        ││
│  │ Total Value Locked: $1,234,567 | 24h Volume: $89,012           ││
│  │ © 2025 SwiftBridge | [GitHub] [Docs] [Discord]                 ││
│  └─────────────────────────────────────────────────────────────────┘│
└──────────────────────────────────────────────────────────────────────┘
```

#### 4.2.2 头部导航栏设计

**组件结构**：
```tsx
<header className="sticky top-0 z-50 backdrop-blur-lg bg-slate-900/80 border-b border-white/10">
  <div className="container mx-auto px-4 h-16 flex items-center justify-between">
    {/* Logo */}
    <div className="flex items-center gap-2">
      <img src="/logo.svg" alt="SwiftBridge" className="h-8 w-8" />
      <span className="text-xl font-bold bg-gradient-to-r from-blue-500 to-purple-600 bg-clip-text text-transparent">
        SwiftBridge
      </span>
    </div>

    {/* Navigation Links */}
    <nav className="hidden md:flex items-center gap-6">
      <a href="#bridge" className="text-slate-300 hover:text-white transition">Bridge</a>
      <a href="#history" className="text-slate-300 hover:text-white transition">History</a>
      <a href="https://docs.swiftbridge.io" className="text-slate-300 hover:text-white transition">Docs</a>
    </nav>

    {/* Wallet Connection */}
    <div className="flex items-center gap-3">
      {/* Network Indicator */}
      <div className="hidden sm:flex items-center gap-2 px-3 py-1.5 rounded-lg bg-slate-800 border border-slate-700">
        <div className="h-2 w-2 rounded-full bg-green-500 animate-pulse" />
        <span className="text-sm text-slate-300">Sepolia</span>
      </div>

      {/* Connect Wallet Button */}
      {!isConnected ? (
        <button className="px-4 py-2 rounded-lg bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-medium transition">
          Connect Wallet
        </button>
      ) : (
        <button className="px-4 py-2 rounded-lg bg-slate-800 border border-slate-700 hover:border-slate-600 text-white font-medium transition flex items-center gap-2">
          <div className="h-6 w-6 rounded-full bg-gradient-to-br from-blue-400 to-purple-600" />
          <span className="font-mono">{address.slice(0,6)}...{address.slice(-4)}</span>
        </button>
      )}
    </div>
  </div>
</header>
```

**功能说明**：
- **Logo区域**：点击返回首页，使用品牌渐变色
- **导航链接**：Bridge（跨链）、History（历史记录）、Docs（文档）
- **网络指示器**：显示当前连接的链，绿点表示在线
- **钱包按钮**：未连接显示"Connect Wallet"，已连接显示地址缩写和头像

#### 4.2.3 跨链桥接表单设计

**表单组件结构**：
```tsx
<div className="max-w-lg mx-auto p-6 rounded-2xl bg-slate-800/50 backdrop-blur-md border border-white/10 shadow-2xl">
  <h2 className="text-2xl font-bold mb-6 text-center">Bridge Assets</h2>

  {/* Source Chain */}
  <div className="mb-4">
    <label className="block text-sm font-medium text-slate-300 mb-2">From</label>
    <select className="w-full px-4 py-3 rounded-xl bg-slate-900 border border-slate-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 text-white transition">
      <option value="11155111">Ethereum Sepolia</option>
      <option value="1197">Imua Testnet</option>
      <option value="210425">PlatON Mainnet</option>
      <option value="7001">ZetaChain Testnet</option>
    </select>
  </div>

  {/* Token Selection */}
  <div className="mb-4">
    <label className="block text-sm font-medium text-slate-300 mb-2">Asset</label>
    <div className="flex items-center gap-3 px-4 py-3 rounded-xl bg-slate-900 border border-slate-700">
      <img src="/tokens/eth.svg" className="h-8 w-8 rounded-full" />
      <div className="flex-1">
        <div className="font-medium text-white">ETH</div>
        <div className="text-xs text-slate-400">Ethereum</div>
      </div>
      <svg className="h-5 w-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
      </svg>
    </div>
  </div>

  {/* Amount Input */}
  <div className="mb-4">
    <label className="block text-sm font-medium text-slate-300 mb-2">Amount</label>
    <div className="relative">
      <input
        type="number"
        placeholder="0.0"
        className="w-full px-4 py-3 pr-20 rounded-xl bg-slate-900 border border-slate-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 text-white text-lg transition"
      />
      <button className="absolute right-3 top-1/2 -translate-y-1/2 px-3 py-1 rounded-lg bg-blue-600 hover:bg-blue-500 text-white text-sm font-medium transition">
        MAX
      </button>
    </div>
    <div className="mt-1 text-sm text-slate-400">
      Balance: <span className="text-white font-medium">10.5 ETH</span>
    </div>
  </div>

  {/* Swap Direction Icon */}
  <div className="flex justify-center my-4">
    <button className="p-2 rounded-full bg-slate-900 border border-slate-700 hover:border-blue-500 hover:rotate-180 transition-all duration-300">
      <svg className="h-6 w-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
      </svg>
    </button>
  </div>

  {/* Target Chain */}
  <div className="mb-4">
    <label className="block text-sm font-medium text-slate-300 mb-2">To</label>
    <select className="w-full px-4 py-3 rounded-xl bg-slate-900 border border-slate-700 focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20 text-white transition">
      <option value="1197">Imua Testnet</option>
      <option value="210425">PlatON Mainnet</option>
      <option value="7001">ZetaChain Testnet</option>
      <option value="11155111">Ethereum Sepolia</option>
    </select>
  </div>

  {/* Recipient Address (Optional) */}
  <div className="mb-4">
    <label className="block text-sm font-medium text-slate-300 mb-2">
      Recipient Address <span className="text-xs text-slate-500">(Optional)</span>
    </label>
    <input
      type="text"
      placeholder="0x... (defaults to your address)"
      className="w-full px-4 py-3 rounded-xl bg-slate-900 border border-slate-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 text-white font-mono text-sm transition"
    />
  </div>

  {/* Transaction Summary */}
  <div className="mb-6 p-4 rounded-xl bg-slate-900/50 border border-slate-700">
    <div className="flex justify-between items-center mb-2">
      <span className="text-sm text-slate-400">You will receive</span>
      <span className="text-lg font-semibold text-white">~1.97 ETH</span>
    </div>
    <div className="flex justify-between items-center mb-2">
      <span className="text-sm text-slate-400">Bridge Fee (0.3%)</span>
      <span className="text-sm text-slate-300">0.03 ETH</span>
    </div>
    <div className="flex justify-between items-center mb-2">
      <span className="text-sm text-slate-400">Estimated Time</span>
      <span className="text-sm text-slate-300">~2 minutes</span>
    </div>
    <div className="flex justify-between items-center">
      <span className="text-sm text-slate-400">Gas Fee</span>
      <span className="text-sm text-yellow-500">~0.003 ETH ($8.50)</span>
    </div>
  </div>

  {/* Action Buttons */}
  {needsApproval && (
    <button className="w-full mb-3 px-6 py-3 rounded-xl bg-yellow-600 hover:bg-yellow-500 text-white font-semibold transition">
      Approve USDC
    </button>
  )}
  <button className="w-full px-6 py-4 rounded-xl bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold text-lg shadow-lg shadow-blue-500/50 transition-all hover:shadow-xl hover:shadow-blue-500/60">
    Lock & Bridge
  </button>
</div>
```

#### 4.2.4 交易历史列表设计

**列表组件结构**：
```tsx
<div className="max-w-4xl mx-auto p-6 rounded-2xl bg-slate-800/50 backdrop-blur-md border border-white/10 shadow-2xl">
  <div className="flex items-center justify-between mb-6">
    <h2 className="text-2xl font-bold">Transaction History</h2>
    <div className="flex items-center gap-2">
      {/* Filter Dropdown */}
      <select className="px-3 py-2 rounded-lg bg-slate-900 border border-slate-700 text-white text-sm">
        <option value="all">All Status</option>
        <option value="pending">Pending</option>
        <option value="minted">Completed</option>
        <option value="failed">Failed</option>
      </select>
    </div>
  </div>

  {/* Transaction Items */}
  <div className="space-y-3">
    {transactions.map(tx => (
      <div key={tx.txId} className="p-4 rounded-xl bg-slate-900/50 border border-slate-700 hover:border-slate-600 transition cursor-pointer">
        <div className="flex items-center justify-between">
          {/* Transaction Info */}
          <div className="flex-1">
            <div className="flex items-center gap-3 mb-2">
              <span className="font-mono text-sm text-blue-400">
                {tx.txId.slice(0, 10)}...{tx.txId.slice(-8)}
              </span>
              {/* Status Badge */}
              <span className={`px-2 py-1 rounded-lg text-xs font-medium ${
                tx.status === 'minted' ? 'bg-green-500/20 text-green-400' :
                tx.status === 'processing' ? 'bg-blue-500/20 text-blue-400' :
                tx.status === 'failed' ? 'bg-red-500/20 text-red-400' :
                'bg-yellow-500/20 text-yellow-400'
              }`}>
                {tx.status === 'minted' ? '✓ Completed' :
                 tx.status === 'processing' ? '⏳ Processing' :
                 tx.status === 'failed' ? '✗ Failed' : '⏸ Pending'}
              </span>
            </div>

            <div className="flex items-center gap-2 text-sm text-slate-300">
              <span className="font-medium">{tx.sourceChain}</span>
              <svg className="h-4 w-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" />
              </svg>
              <span className="font-medium">{tx.targetChain}</span>
              <span className="mx-2 text-slate-600">|</span>
              <span className="font-semibold">{tx.amount} {tx.token}</span>
              <span className="mx-2 text-slate-600">|</span>
              <span className="text-slate-400">{formatTime(tx.timestamp)}</span>
            </div>
          </div>

          {/* View Details Button */}
          <button className="px-4 py-2 rounded-lg bg-slate-800 border border-slate-700 hover:border-blue-500 text-white text-sm font-medium transition">
            View Details
          </button>
        </div>
      </div>
    ))}
  </div>

  {/* Load More */}
  <button className="w-full mt-6 px-6 py-3 rounded-xl bg-slate-900 border border-slate-700 hover:border-slate-600 text-white font-medium transition">
    Load More
  </button>
</div>
```

#### 4.2.5 实时状态追踪组件

**进度条组件**：
```tsx
<div className="p-6 rounded-2xl bg-slate-800/50 backdrop-blur-md border border-white/10 shadow-2xl">
  <h3 className="text-lg font-semibold mb-4">Bridge Progress</h3>

  {/* Progress Steps */}
  <div className="relative">
    {/* Progress Line */}
    <div className="absolute left-4 top-8 bottom-8 w-0.5 bg-slate-700" />
    <div
      className="absolute left-4 top-8 w-0.5 bg-blue-500 transition-all duration-500"
      style={{ height: `${(currentStep / totalSteps) * 100}%` }}
    />

    {/* Steps */}
    <div className="space-y-6">
      {steps.map((step, index) => (
        <div key={index} className="flex items-start gap-4 relative">
          {/* Step Icon */}
          <div className={`flex-shrink-0 h-8 w-8 rounded-full border-2 flex items-center justify-center z-10 transition ${
            step.status === 'completed' ? 'bg-green-500 border-green-500' :
            step.status === 'active' ? 'bg-blue-500 border-blue-500 animate-pulse' :
            'bg-slate-900 border-slate-700'
          }`}>
            {step.status === 'completed' ? (
              <svg className="h-5 w-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            ) : step.status === 'active' ? (
              <div className="h-3 w-3 rounded-full bg-white" />
            ) : (
              <div className="h-3 w-3 rounded-full bg-slate-600" />
            )}
          </div>

          {/* Step Content */}
          <div className="flex-1 pt-1">
            <div className="text-white font-medium">{step.title}</div>
            <div className="text-sm text-slate-400 mt-1">{step.description}</div>
            {step.txHash && (
              <a
                href={`${step.explorerUrl}/tx/${step.txHash}`}
                target="_blank"
                className="inline-flex items-center gap-1 mt-2 text-xs text-blue-400 hover:text-blue-300"
              >
                View on Explorer
                <svg className="h-3 w-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
            )}
          </div>
        </div>
      ))}
    </div>
  </div>
</div>
```

**步骤数据示例**：
```typescript
const steps = [
  {
    title: 'Locking on Source Chain',
    description: 'Your assets are being locked on Ethereum Sepolia',
    status: 'completed',
    txHash: '0xabcdef123456...',
    explorerUrl: 'https://sepolia.etherscan.io'
  },
  {
    title: 'Relayer Signing',
    description: 'Relayer is generating ECDSA signature',
    status: 'active',
    txHash: null,
    explorerUrl: null
  },
  {
    title: 'Minting on Target Chain',
    description: 'Awaiting mint transaction on Imua Testnet',
    status: 'pending',
    txHash: null,
    explorerUrl: null
  },
  {
    title: 'Completed',
    description: 'You will receive maoETH in your wallet',
    status: 'pending',
    txHash: null,
    explorerUrl: null
  }
];
```

---

### 4.3 响应式设计适配

#### 4.3.1 移动端适配（< 640px）

**布局调整**：
- **单列布局**：所有卡片堆叠显示，跨链表单占满屏宽
- **隐藏元素**：隐藏网络指示器、部分统计数据
- **简化导航**：使用汉堡菜单（☰）折叠导航链接
- **触摸优化**：按钮高度至少44px，增加点击区域

**移动端特定样式**：
```tsx
<div className="
  px-4 sm:px-6 lg:px-8        // 渐进式padding
  grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3  // 响应式网格
  gap-4 sm:gap-6 lg:gap-8     // 渐进式间距
">
  <button className="
    w-full sm:w-auto           // 移动端全宽，桌面端自适应
    text-base sm:text-lg       // 移动端较小字体
    py-3 sm:py-4               // 移动端较小padding
  ">
    Connect Wallet
  </button>
</div>
```

#### 4.3.2 平板端适配（640px - 1024px）

**布局调整**：
- **两列布局**：跨链表单 + 交易历史并排显示
- **显示核心功能**：保留网络指示器和主要统计数据
- **优化表单**：适当缩小间距，提高空间利用率

#### 4.3.3 桌面端优化（> 1024px）

**布局调整**：
- **三列布局**：跨链表单 + 实时状态 + 交易历史
- **完整功能**：显示所有统计数据、图表和高级功能
- **最大宽度限制**：内容区max-width: 1280px，居中显示

---

### 4.4 交互设计与用户体验

#### 4.4.1 加载状态设计

**骨架屏（Skeleton Screen）**：
```tsx
<div className="animate-pulse">
  <div className="h-8 bg-slate-700 rounded w-1/3 mb-4"></div>
  <div className="h-12 bg-slate-700 rounded mb-3"></div>
  <div className="h-12 bg-slate-700 rounded mb-3"></div>
  <div className="h-20 bg-slate-700 rounded"></div>
</div>
```

**加载指示器**：
```tsx
<div className="flex items-center justify-center">
  <div className="h-8 w-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
  <span className="ml-3 text-slate-300">Loading...</span>
</div>
```

#### 4.4.2 错误提示设计

**Toast通知**：
```tsx
<div className="fixed top-4 right-4 z-50 max-w-md p-4 rounded-xl bg-red-500/90 backdrop-blur-md border border-red-400 shadow-lg animate-slide-in-right">
  <div className="flex items-start gap-3">
    <svg className="h-6 w-6 text-white flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
    <div className="flex-1">
      <div className="font-semibold text-white">Transaction Failed</div>
      <div className="text-sm text-red-100 mt-1">Insufficient balance for gas fee</div>
    </div>
    <button className="text-white hover:text-red-100">
      <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>
  </div>
</div>
```

#### 4.4.3 成功反馈设计

**成功动画**：
```tsx
<div className="flex flex-col items-center justify-center p-8">
  <div className="h-16 w-16 rounded-full bg-green-500/20 border-4 border-green-500 flex items-center justify-center animate-scale-in">
    <svg className="h-10 w-10 text-green-500 animate-check-mark" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
    </svg>
  </div>
  <div className="mt-4 text-xl font-semibold text-white">Bridge Successful!</div>
  <div className="mt-2 text-sm text-slate-400">Your assets will arrive in ~2 minutes</div>
  <button className="mt-6 px-6 py-3 rounded-xl bg-blue-600 hover:bg-blue-500 text-white font-medium transition">
    View Transaction
  </button>
</div>
```

---

## 5 内部接口设计

### 5.1 智能合约接口设计

#### 5.1.1 Source.lock() - ERC20代币锁定接口

**接口编号**：IF_SB_01

**接口属性**：

| 属性 | 说明 |
|------|------|
| **接口名称** | lock |
| **所属合约** | Source.sol（部署在源链） |
| **函数签名** | `function lock(address _token, uint256 _amount, uint256 _destinationChainId, address _recipient) external whenNotPaused nonReentrant` |
| **访问权限** | 公开（任何用户可调用） |
| **修饰符** | whenNotPaused（合约未暂停）、nonReentrant（防重入） |
| **数据来源** | 用户通过前端Web3钱包调用 |
| **Gas消耗** | 约120,000 Gas（取决于代币类型） |

**输入参数**：

| 参数名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| _token | address | ERC20代币合约地址 | 0xe5a26a2c90b6e629861bb25f10177f06720e5335（maoUSDC） |
| _amount | uint256 | 锁定数量（最小单位） | 1000000（1 USDC，6位小数） |
| _destinationChainId | uint256 | 目标链ID | 1197（Imua Testnet） |
| _recipient | address | 目标链接收地址 | 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb |

**输出信息**：

| 输出项 | 类型 | 说明 |
|--------|------|------|
| AssetLocked事件 | event | 触发事件，包含txId、user、destinationChainId、recipientAddress、tokenAddress、amount、fee |
| 返回值 | 无 | 函数无返回值，成功执行即表示锁定成功 |

**处理流程**：

```
1. [输入验证]
   ├─ require(_amount > 0)
   ├─ require(_recipient != address(0))
   └─ 检查合约未暂停（whenNotPaused）

2. [手续费计算]
   ├─ 调用_calculateFee(_amount)
   ├─ amountAfterFee = _amount - fee
   └─ require(amountAfterFee > 0)

3. [累积手续费]
   └─ accumulatedFees[_token] += fee

4. [转账代币]
   └─ IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount)

5. [生成交易ID]
   ├─ nonce = _nonce++
   └─ txId = keccak256(abi.encodePacked(block.chainid, address(this), nonce))

6. [触发事件]
   └─ emit AssetLocked(txId, msg.sender, _destinationChainId, _recipient, _token, amountAfterFee, fee)
```

**接口调用示例（Ethers.js v6）**：

```typescript
import { ethers } from 'ethers';

// 初始化provider和signer
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();

// Source合约实例
const sourceContract = new ethers.Contract(
  '0x4195868b54b70d4420E6203e85A4b92a6705FF28', // Sepolia Source合约地址
  SOURCE_ABI,
  signer
);

// ERC20代币合约实例
const tokenContract = new ethers.Contract(
  '0xe5a26a2c90b6e629861bb25f10177f06720e5335', // USDC地址
  ERC20_ABI,
  signer
);

// 步骤1: 授权Source合约使用代币
const amount = ethers.parseUnits('10', 6); // 10 USDC (6 decimals)
const approveTx = await tokenContract.approve(sourceContract.target, amount);
await approveTx.wait();
console.log('✓ Token approved');

// 步骤2: 调用lock函数
const lockTx = await sourceContract.lock(
  '0xe5a26a2c90b6e629861bb25f10177f06720e5335', // USDC地址
  amount,
  1197, // Imua Testnet Chain ID
  '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // 接收地址
  {
    gasLimit: 150000 // 手动设置Gas limit
  }
);

console.log('Transaction sent:', lockTx.hash);

// 步骤3: 等待交易确认
const receipt = await lockTx.wait();
console.log('✓ Transaction confirmed:', receipt.hash);

// 步骤4: 解析事件
const event = receipt.logs.find(log =>
  log.topics[0] === ethers.id('AssetLocked(bytes32,address,uint256,address,address,uint256,uint256)')
);
const parsedEvent = sourceContract.interface.parseLog(event);
console.log('Transaction ID:', parsedEvent.args.transactionId);
console.log('Amount locked:', ethers.formatUnits(parsedEvent.args.amount, 6), 'USDC');
console.log('Fee charged:', ethers.formatUnits(parsedEvent.args.fee, 6), 'USDC');
```

**错误处理**：

| 错误信息 | 触发条件 | 处理方式 |
|---------|---------|---------|
| "Source: amount must be greater than zero" | _amount = 0 | 前端提示用户输入有效金额 |
| "Source: invalid recipient address" | _recipient = 0x0 | 前端验证地址格式 |
| "Source: amount must be greater than fee" | _amount ≤ fee | 前端提示最小锁定金额 |
| "ERC20: insufficient allowance" | 授权额度不足 | 前端提示先调用approve() |
| "ERC20: transfer amount exceeds balance" | 余额不足 | 前端显示余额并禁用按钮 |
| "Pausable: paused" | 合约已暂停 | 前端显示系统维护提示 |

---

#### 5.1.2 Source.lockNative() - 原生币锁定接口

**接口编号**：IF_SB_02

**接口属性**：

| 属性 | 说明 |
|------|------|
| **接口名称** | lockNative |
| **所属合约** | Source.sol（部署在源链） |
| **函数签名** | `function lockNative(uint256 _destinationChainId, address _recipient) external payable whenNotPaused nonReentrant` |
| **访问权限** | 公开（任何用户可调用） |
| **修饰符** | payable（接收原生币）、whenNotPaused、nonReentrant |
| **Gas消耗** | 约100,000 Gas |

**输入参数**：

| 参数名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| _destinationChainId | uint256 | 目标链ID | 1197（Imua Testnet） |
| _recipient | address | 目标链接收地址 | 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb |
| msg.value | uint256（隐式） | 锁定的原生币数量（wei） | 2000000000000000000（2 ETH） |

**接口调用示例**：

```typescript
const lockNativeTx = await sourceContract.lockNative(
  1197, // Imua Testnet
  '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
  {
    value: ethers.parseEther('2.0'), // 发送2 ETH
    gasLimit: 120000
  }
);

await lockNativeTx.wait();
console.log('✓ Native token locked');
```

---

#### 5.1.3 Source.unlock() - 资产解锁接口

**接口编号**：IF_SB_03

**接口属性**：

| 属性 | 说明 |
|------|------|
| **接口名称** | unlock |
| **所属合约** | Source.sol（部署在源链） |
| **函数签名** | `function unlock(bytes32 _txId, address _token, address _recipient, uint256 _amount, bytes memory _signature) external whenNotPaused nonReentrant` |
| **访问权限** | 公开（但需中继器签名验证） |
| **调用者** | 中继器（Relayer），监听Target链的TokensBurned事件后调用 |
| **Gas消耗** | 约150,000 Gas（含签名验证） |

**输入参数**：

| 参数名 | 类型 | 说明 |
|--------|------|------|
| _txId | bytes32 | 原始burn交易的唯一ID |
| _token | address | 要解锁的代币地址（address(0)表示原生币） |
| _recipient | address | 接收解锁资产的地址 |
| _amount | uint256 | 解锁数量 |
| _signature | bytes | 中继器的ECDSA签名（65字节） |

**处理流程**：

```
1. [防重放检查]
   ├─ require(!processedUnlockTxs[_txId])
   └─ require(relayerSigner != address(0))

2. [签名验证]
   ├─ messageHash = keccak256(abi.encodePacked(_txId, _token, _recipient, _amount))
   ├─ ethSignedMessageHash = messageHash.toEthSignedMessageHash()
   ├─ signer = ethSignedMessageHash.recover(_signature)
   └─ require(signer == relayerSigner)

3. [标记已处理]
   └─ processedUnlockTxs[_txId] = true

4. [转账资产]
   ├─ if (_token == address(0))
   │   └─ 原生币转账: recipient.call{value: _amount}("")
   └─ else
       └─ ERC20转账: IERC20(_token).safeTransfer(_recipient, _amount)

5. [触发事件]
   └─ emit AssetUnlocked(_txId, _recipient, _token, _amount)
```

---

#### 5.1.4 Target.mint() - 映射代币铸造接口

**接口编号**：IF_SB_04

**接口属性**：

| 属性 | 说明 |
|------|------|
| **接口名称** | mint |
| **所属合约** | Target.sol（部署在目标链） |
| **函数签名** | `function mint(bytes32 txId, address recipient, uint256 amount, bytes memory signature) external onlyRole(MINTER_ROLE) whenNotPaused` |
| **访问权限** | 限定角色（MINTER_ROLE） |
| **调用者** | 中继器（需预先被授予MINTER_ROLE） |
| **Gas消耗** | 约180,000 Gas（含ERC20铸造） |

**输入参数**：

| 参数名 | 类型 | 说明 |
|--------|------|------|
| txId | bytes32 | 源链锁定交易的唯一ID |
| recipient | address | 接收映射代币的地址 |
| amount | uint256 | 铸造数量 |
| signature | bytes | 中继器的ECDSA签名 |

**处理流程**：

```
1. [权限检查]
   └─ onlyRole(MINTER_ROLE)

2. [输入验证]
   ├─ if (recipient == address(0)) revert InvalidRecipient()
   ├─ if (amount == 0) revert InvalidAmount()
   └─ if (processedMintTxs[txId]) revert TransactionAlreadyProcessed()

3. [签名验证]
   ├─ messageHash = keccak256(abi.encodePacked(txId, recipient, amount, address(this)))
   ├─ ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash))
   ├─ recoveredSigner = messageHash.recover(signature)
   └─ if (recoveredSigner != relayerSigner) revert InvalidSignature()

4. [防重放标记]
   └─ processedMintTxs[txId] = true

5. [铸造代币]
   └─ _mint(recipient, amount)

6. [触发事件]
   └─ emit TokensMinted(txId, recipient, amount, msg.sender)
```

**接口调用示例（中继器端）**：

```typescript
// 中继器监听到AssetLocked事件后调用
async function handleAssetLocked(event) {
  const { transactionId, recipientAddress, amount, destinationChainId } = event.args;

  // 生成签名
  const messageHash = ethers.keccak256(
    ethers.solidityPacked(
      ['bytes32', 'address', 'uint256', 'address'],
      [transactionId, recipientAddress, amount, targetContractAddress]
    )
  );
  const signature = await relayerWallet.signMessage(ethers.getBytes(messageHash));

  // 调用Target.mint()
  const targetContract = new ethers.Contract(targetContractAddress, TARGET_ABI, relayerWallet);
  const mintTx = await targetContract.mint(
    transactionId,
    recipientAddress,
    amount,
    signature,
    { gasLimit: 200000 }
  );

  await mintTx.wait();
  console.log('✓ Minted on target chain:', mintTx.hash);
}
```

---

#### 5.1.5 Target.burn() - 映射代币销毁接口

**接口编号**：IF_SB_05

**接口属性**：

| 属性 | 说明 |
|------|------|
| **接口名称** | burn |
| **所属合约** | Target.sol（部署在目标链） |
| **函数签名** | `function burn(uint256 amount, address recipientOnSource) public whenNotPaused` |
| **访问权限** | 公开（任何持有代币的用户可调用） |
| **Gas消耗** | 约80,000 Gas |

**输入参数**：

| 参数名 | 类型 | 说明 |
|--------|------|------|
| amount | uint256 | 要销毁的代币数量 |
| recipientOnSource | address | 源链上接收解锁资产的地址 |

**处理流程**：

```
1. [输入验证]
   ├─ if (amount == 0) revert InvalidAmount()
   └─ if (recipientOnSource == address(0)) revert InvalidRecipient()

2. [生成burnTxId]
   └─ burnTxId = keccak256(abi.encodePacked(
        block.timestamp, msg.sender, amount, burnTxCounter++, block.number
      ))

3. [销毁代币]
   └─ _burn(msg.sender, amount)

4. [触发事件]
   └─ emit TokensBurned(burnTxId, msg.sender, sourceChainId, recipientOnSource, amount)
```

**接口调用示例**：

```typescript
const targetContract = new ethers.Contract(TARGET_ADDRESS, TARGET_ABI, signer);

// 销毁2个maoETH，解锁到指定地址
const burnTx = await targetContract.burn(
  ethers.parseEther('2.0'),
  '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // 源链接收地址
  { gasLimit: 100000 }
);

await burnTx.wait();
console.log('✓ Tokens burned, awaiting unlock on source chain');
```

---

### 5.2 RESTful API接口设计

#### 5.2.1 POST /api/crossLockInfo - 创建跨链记录

**接口编号**：IF_API_01

**接口属性**：

| 属性 | 说明 |
|------|------|
| **HTTP方法** | POST |
| **端点** | /api/crossLockInfo |
| **认证** | 无需认证（公开） |
| **Content-Type** | application/json |
| **响应格式** | JSON |

**请求体（Request Body）**：

```json
{
  "txId": "0x1234567890abcdef...",
  "sourceTxHash": "0xabcdef1234567890...",
  "sourceChain": "Sepolia",
  "targetChain": "Imua",
  "tokenAddress": "0xe5a26a...",
  "amount": "1000000",
  "fee": "3000",
  "user": "0x742d35Cc...",
  "recipient": "0x742d35Cc...",
  "status": "pending"
}
```

**响应体（Response Body）**：

```json
{
  "success": true,
  "message": "Cross-chain record created successfully",
  "data": {
    "_id": "60a7c8d4e4b0f3a2d8c9e1f2",
    "txId": "0x1234567890abcdef...",
    "createdAt": "2025-01-15T10:30:00.000Z",
    "updatedAt": "2025-01-15T10:30:00.000Z"
  }
}
```

**实现示例（Express.js）**：

```javascript
app.post('/api/crossLockInfo', async (req, res) => {
  try {
    const { txId, sourceTxHash, sourceChain, targetChain, tokenAddress, amount, fee, user, recipient, status } = req.body;

    // 验证必填字段
    if (!txId || !sourceChain || !targetChain || !amount || !user || !recipient) {
      return res.status(400).json({ success: false, message: 'Missing required fields' });
    }

    // 创建记录
    const record = new CrossBridgeRecord({
      txId,
      sourceTxHash,
      sourceChain,
      targetChain,
      tokenAddress,
      amount,
      fee,
      user,
      recipient,
      status: status || 'pending',
      createdAt: new Date(),
      updatedAt: new Date()
    });

    await record.save();

    res.status(201).json({
      success: true,
      message: 'Cross-chain record created successfully',
      data: {
        _id: record._id,
        txId: record.txId,
        createdAt: record.createdAt,
        updatedAt: record.updatedAt
      }
    });
  } catch (error) {
    console.error('Error creating record:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});
```

---

#### 5.2.2 GET /api/crossLockInfo/:txId - 查询单条记录

**接口编号**：IF_API_02

**请求示例**：
```
GET /api/crossLockInfo/0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

**响应体**：

```json
{
  "success": true,
  "data": {
    "_id": "60a7c8d4e4b0f3a2d8c9e1f2",
    "txId": "0x1234567890abcdef...",
    "sourceTxHash": "0xabcdef1234...",
    "targetTxHash": "0x9876543210...",
    "sourceChain": "Sepolia",
    "targetChain": "Imua",
    "tokenAddress": "0xe5a26a...",
    "amount": "1000000",
    "fee": "3000",
    "user": "0x742d35Cc...",
    "recipient": "0x742d35Cc...",
    "status": "minted",
    "createdAt": "2025-01-15T10:30:00.000Z",
    "updatedAt": "2025-01-15T10:32:45.000Z"
  }
}
```

---

#### 5.2.3 GET /api/crossLockInfo/user/:address - 查询用户所有记录

**接口编号**：IF_API_03

**请求参数**：

| 参数名 | 类型 | 位置 | 说明 |
|--------|------|------|------|
| address | string | path | 用户钱包地址 |
| page | number | query | 页码（默认1） |
| limit | number | query | 每页数量（默认10） |
| status | string | query | 状态筛选（可选） |

**请求示例**：
```
GET /api/crossLockInfo/user/0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb?page=1&limit=10&status=minted
```

**响应体**：

```json
{
  "success": true,
  "data": {
    "transactions": [
      {
        "txId": "0x1234...",
        "sourceChain": "Sepolia",
        "targetChain": "Imua",
        "amount": "1000000",
        "status": "minted",
        "createdAt": "2025-01-15T10:30:00.000Z"
      },
      // ... more transactions
    ],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 25,
      "totalPages": 3
    }
  }
}
```

---

### 5.3 WebSocket接口设计

#### 5.3.1 连接建立

**端点**：`ws://localhost:8888` 或 `wss://api.swiftbridge.io`

**客户端连接示例**：

```typescript
import { io } from 'socket.io-client';

const socket = io('ws://localhost:8888', {
  transports: ['websocket'],
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: 5
});

socket.on('connect', () => {
  console.log('✓ WebSocket connected');
});

socket.on('disconnect', () => {
  console.log('✗ WebSocket disconnected');
});
```

#### 5.3.2 订阅交易状态更新

**事件名称**：`subscribe:transaction`

**发送消息**：

```typescript
socket.emit('subscribe:transaction', {
  txId: '0x1234567890abcdef...'
});
```

**接收消息**：

```typescript
socket.on('transaction:update', (data) => {
  console.log('Transaction update:', data);
  // {
  //   txId: '0x1234...',
  //   status: 'processing', // pending | processing | minted | failed
  //   targetTxHash: '0xabcd...',
  //   timestamp: '2025-01-15T10:31:30.000Z'
  // }
});
```

---

## 6 系统出错处理设计

### 6.1 出错信息分类

#### 6.1.1 前端错误处理

| 错误编号 | 错误场景 | 错误信息 | 处理方式 |
|---------|---------|---------|---------|
| FE_ERR_001 | 钱包未连接 | "Please connect your wallet first" | 显示连接钱包按钮，引导用户点击 |
| FE_ERR_002 | 网络不匹配 | "Wrong network. Please switch to {chainName}" | 提供一键切换按钮（调用wallet_switchEthereumChain） |
| FE_ERR_003 | 余额不足 | "Insufficient balance. Required: {amount} {token}" | 高亮显示余额，禁用提交按钮 |
| FE_ERR_004 | 授权额度不足 | "Token approval required" | 显示[Approve]按钮，说明授权作用 |
| FE_ERR_005 | 输入金额无效 | "Please enter a valid amount" | 红色边框高亮输入框，显示错误提示 |
| FE_ERR_006 | 接收地址无效 | "Invalid recipient address" | 实时验证地址格式，显示checksum警告 |
| FE_ERR_007 | 目标链不支持 | "Target chain not supported" | 显示支持的链列表，灰显不支持的选项 |
| FE_ERR_008 | WebSocket断开 | "Real-time updates unavailable. Reconnecting..." | 显示离线图标，5秒后自动重连 |

**前端错误处理示例代码**：

```typescript
// 网络检查
async function checkNetwork() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const network = await provider.getNetwork();

  if (!SUPPORTED_CHAIN_IDS.includes(Number(network.chainId))) {
    showError('FE_ERR_002', `Wrong network. Please switch to Sepolia`);
    return false;
  }
  return true;
}

// 余额检查
async function checkBalance(amount: bigint, tokenAddress: string) {
  const balance = await getTokenBalance(userAddress, tokenAddress);

  if (balance < amount) {
    showError('FE_ERR_003', `Insufficient balance. Required: ${ethers.formatUnits(amount, 18)} ETH`);
    return false;
  }
  return true;
}

// 统一错误显示函数
function showError(code: string, message: string) {
  toast.error(message, {
    duration: 5000,
    position: 'top-right',
    icon: '⚠️'
  });

  // 记录到错误日志
  logError({
    code,
    message,
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent
  });
}
```

#### 6.1.2 智能合约错误处理

| 错误编号 | 错误类型 | 触发条件 | Revert消息 | Gas退还 |
|---------|---------|---------|-----------|--------|
| SC_ERR_001 | 金额为零 | amount = 0 | "Source: amount must be greater than zero" | 是 |
| SC_ERR_002 | 接收地址无效 | recipient = 0x0 | "Source: invalid recipient address" | 是 |
| SC_ERR_003 | 手续费过高 | amount ≤ fee | "Source: amount must be greater than fee" | 是 |
| SC_ERR_004 | 授权不足 | allowance < amount | "ERC20: insufficient allowance" | 是 |
| SC_ERR_005 | 余额不足 | balance < amount | "ERC20: transfer amount exceeds balance" | 是 |
| SC_ERR_006 | 合约暂停 | paused = true | "Pausable: paused" | 是 |
| SC_ERR_007 | 重放攻击 | processedUnlockTxs[txId] = true | "Source: transaction already processed" | 是 |
| SC_ERR_008 | 签名无效 | signer != relayerSigner | "Source: invalid signature" | 是 |
| SC_ERR_009 | 权限不足 | !hasRole(MINTER_ROLE) | "AccessControl: account missing role" | 是 |
| SC_ERR_010 | 自定义错误 | custom error | InvalidRecipient() / InvalidAmount() | 是（节省Gas） |

**智能合约错误处理示例**：

```solidity
// Source.sol中的错误处理
function lock(...) external {
    // 输入验证
    require(_amount > 0, "Source: amount must be greater than zero");
    require(_recipient != address(0), "Source: invalid recipient address");

    // 手续费验证
    uint256 fee = _calculateFee(_amount);
    uint256 amountAfterFee = _amount - fee;
    require(amountAfterFee > 0, "Source: amount must be greater than fee");

    // ... 其他逻辑
}

// Target.sol中使用自定义错误（节省Gas）
error InvalidRecipient();
error InvalidAmount();
error TransactionAlreadyProcessed();

function mint(...) external {
    if (recipient == address(0)) revert InvalidRecipient();
    if (amount == 0) revert InvalidAmount();
    if (processedMintTxs[txId]) revert TransactionAlreadyProcessed();

    // ... 其他逻辑
}
```

**前端捕获合约错误示例**：

```typescript
try {
  const tx = await sourceContract.lock(token, amount, destChainId, recipient);
  await tx.wait();
  showSuccess('Transaction confirmed!');
} catch (error: any) {
  // 解析revert原因
  if (error.code === 'CALL_EXCEPTION') {
    const reason = error.reason || error.data?.message || 'Unknown error';

    if (reason.includes('insufficient allowance')) {
      showError('SC_ERR_004', 'Please approve token first');
      setShowApproveButton(true);
    } else if (reason.includes('amount exceeds balance')) {
      showError('SC_ERR_005', 'Insufficient balance');
    } else if (reason.includes('paused')) {
      showError('SC_ERR_006', 'Bridge is currently paused for maintenance');
    } else {
      showError('SC_ERR_UNKNOWN', reason);
    }
  } else if (error.code === 'ACTION_REJECTED') {
    showWarning('Transaction cancelled by user');
  } else {
    showError('SC_ERR_UNKNOWN', error.message);
  }
}
```

#### 6.1.3 中继器错误处理

| 错误编号 | 错误场景 | 处理策略 | 重试次数 | 告警级别 |
|---------|---------|---------|---------|---------|
| RL_ERR_001 | 事件监听失败 | 重新连接RPC节点 | 无限（指数退避） | 警告 |
| RL_ERR_002 | 签名生成失败 | 检查私钥配置，重新签名 | 3次 | 严重 |
| RL_ERR_003 | Mint交易失败 | 增加Gas Price重试 | 5次 | 严重 |
| RL_ERR_004 | Unlock交易失败 | 增加Gas Price重试 | 5次 | 严重 |
| RL_ERR_005 | RPC节点超时 | 切换到备用RPC | 无限 | 警告 |
| RL_ERR_006 | 数据库写入失败 | 重试写入，记录到日志 | 3次 | 严重 |
| RL_ERR_007 | WebSocket推送失败 | 记录失败，等待客户端轮询 | 1次 | 信息 |
| RL_ERR_008 | Gas不足 | 发送告警，暂停服务 | 0次 | 严重 |

**中继器错误处理示例**：

```typescript
// 指数退避重试机制
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number,
  errorCode: string
): Promise<T> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      console.error(`${errorCode} - Attempt ${i + 1} failed:`, error);

      // 指数退避: 2^i * 1000ms
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  // 所有重试失败，发送告警
  await sendAlert({
    level: 'CRITICAL',
    code: errorCode,
    message: `Failed after ${maxRetries} retries: ${lastError.message}`
  });

  throw lastError;
}

// 使用示例
async function processMint(txId, recipient, amount, destChainId) {
  try {
    await retryWithBackoff(
      async () => {
        const signature = await generateMintSignature(txId, recipient, amount, targetContract);
        const tx = await targetContract.mint(txId, recipient, amount, signature, {
          gasLimit: 200000,
          maxFeePerGas: ethers.parseUnits('50', 'gwei')
        });
        return await tx.wait();
      },
      5, // 最多重试5次
      'RL_ERR_003'
    );

    console.log('✓ Mint transaction successful');
    await updateDB(txId, { status: 'minted' });
  } catch (error) {
    console.error('✗ Mint transaction failed permanently:', error);
    await updateDB(txId, { status: 'failed', error: error.message });
  }
}
```

---

### 6.2 补救措施

#### 6.2.1 用户操作错误补救

**实时表单验证**：

```typescript
// 实时验证地址格式
function validateAddress(address: string): boolean {
  if (!address) return false;
  if (!ethers.isAddress(address)) {
    showError('FE_ERR_006', 'Invalid address format');
    return false;
  }

  // 检查checksum
  if (address !== ethers.getAddress(address)) {
    showWarning('Address checksum mismatch. Using checksummed address.');
    return true; // 仍然允许，但提示警告
  }

  return true;
}

// 实时验证金额范围
function validateAmount(amount: string, balance: bigint): boolean {
  if (!amount || parseFloat(amount) <= 0) {
    showError('FE_ERR_005', 'Please enter a valid amount');
    return false;
  }

  const amountWei = ethers.parseEther(amount);
  if (amountWei > balance) {
    showError('FE_ERR_003', 'Insufficient balance');
    return false;
  }

  return true;
}
```

**输入历史记录（LocalStorage）**：

```typescript
// 保存最近使用的地址
function saveRecentAddress(address: string) {
  const recent = JSON.parse(localStorage.getItem('recentAddresses') || '[]');
  if (!recent.includes(address)) {
    recent.unshift(address);
    localStorage.setItem('recentAddresses', JSON.stringify(recent.slice(0, 5)));
  }
}

// 显示历史地址下拉列表
function renderRecentAddresses() {
  const recent = JSON.parse(localStorage.getItem('recentAddresses') || '[]');
  return (
    <datalist id="recent-addresses">
      {recent.map(addr => (
        <option key={addr} value={addr} />
      ))}
    </datalist>
  );
}
```

#### 6.2.2 网络连接问题补救

**自动重连机制**：

```typescript
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 10;

socket.on('disconnect', () => {
  console.log('WebSocket disconnected, attempting to reconnect...');

  const reconnectInterval = setInterval(() => {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      clearInterval(reconnectInterval);
      showError('WS_ERR_001', 'Unable to connect to server. Please refresh the page.');
      return;
    }

    reconnectAttempts++;
    console.log(`Reconnect attempt ${reconnectAttempts}...`);
    socket.connect();
  }, 10000); // 每10秒重试
});

socket.on('connect', () => {
  console.log('✓ WebSocket reconnected');
  reconnectAttempts = 0;
  showSuccess('Connection restored');
});
```

**本地缓存（IndexedDB）**：

```typescript
import { openDB } from 'idb';

// 初始化IndexedDB
const db = await openDB('SwiftBridgeDB', 1, {
  upgrade(db) {
    db.createObjectStore('transactions', { keyPath: 'txId' });
    db.createObjectStore('userSettings', { keyPath: 'key' });
  }
});

// 缓存交易记录
async function cacheTransaction(tx) {
  await db.put('transactions', tx);
}

// 离线时从缓存读取
async function getTransactionsFromCache() {
  return await db.getAll('transactions');
}
```

#### 6.2.3 跨链流程异常补救

**状态监控与自动回滚**：

```solidity
// Source合约中的紧急提款功能（需多签管理员）
function emergencyWithdraw(
    bytes32 _txId,
    address _token,
    address _recipient,
    uint256 _amount
) external onlyRole(DEFAULT_ADMIN_ROLE) {
    require(block.timestamp > lockTimestamps[_txId] + 24 hours, "Too early");
    require(!processedUnlockTxs[_txId], "Already processed");

    processedUnlockTxs[_txId] = true; // 防止重复提款

    if (_token == address(0)) {
        (bool success, ) = _recipient.call{value: _amount}("");
        require(success);
    } else {
        IERC20(_token).safeTransfer(_recipient, _amount);
    }

    emit EmergencyWithdraw(_txId, _recipient, _token, _amount);
}
```

**人工介入工单系统**：

```typescript
// 用户提交异常工单
async function submitSupportTicket(txId: string, issue: string) {
  const ticket = {
    txId,
    issue,
    userAddress: await signer.getAddress(),
    timestamp: new Date().toISOString(),
    status: 'pending'
  };

  // 发送到支持系统
  await fetch('/api/support/tickets', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(ticket)
  });

  showSuccess('Support ticket submitted. We will investigate within 24 hours.');
}
```

#### 6.2.4 安全事件补救

**紧急暂停机制**：

```solidity
// Source和Target合约都继承Pausable
function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _pause(); // 暂停所有lock/unlock/mint/burn操作
    emit EmergencyPause(msg.sender, block.timestamp);
}

function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _unpause();
    emit EmergencyUnpause(msg.sender, block.timestamp);
}
```

**异常检测与自动冻结**：

```typescript
// 中继器监控异常大额转账
const MAX_SINGLE_TRANSFER = ethers.parseEther('100'); // 100 ETH

async function checkAnomalousTransfer(amount: bigint) {
  if (amount > MAX_SINGLE_TRANSFER) {
    // 发送告警
    await sendAlert({
      level: 'CRITICAL',
      message: `Anomalous large transfer detected: ${ethers.formatEther(amount)} ETH`,
      action: 'Manual review required'
    });

    // 暂停自动处理，等待人工审核
    return false;
  }
  return true;
}
```

---

## 7 附录

### 7.1 已部署合约地址

#### 7.1.1 Sepolia测试网（Chain ID: 11155111）

**Source合约**：
- 地址：`0x4195868b54b70d4420E6203e85A4b92a6705FF28`
- 实现合约：`0xf98814782f4daEF28bF8e85BA1d62Aa2d0b54c1E`
- 中继器签名者：`0xC3ef35A3Cb11aa4c4Cb9FC82dCAABE222D78aF5E`
- 区块浏览器：[Sepolia Etherscan](https://sepolia.etherscan.io/address/0x4195868b54b70d4420E6203e85A4b92a6705FF28)

**映射代币（部署在其他链，从Sepolia跨链到此）**：
- maoUSDC (Sepolia): `0xe5a26a2c90b6e629861bb25f10177f06720e5335`
- maoETH (Sepolia): `0x4a91a4a24b6883dbbddc6e6704a3c0e96396d2e9`
- maoEURC (Sepolia): `0xDFEc8F8C99eC22AA21e392Aa00eFb3F517C44987`

#### 7.1.2 Imua Testnet（Chain ID: 1197）

**Source合约**：
- 地址：`0xfcc4936B0b437469F5CE4C3cBD7eAa05CE5f581d`
- 中继器签名者：`0xC3ef35A3Cb11aa4c4Cb9FC82dCAABE222D78aF5E`

**映射代币**：
- maoIMUA (部署在其他链):
  - Sepolia: `0x12306381b1b6ecb4132ff4ce324ed2be3728e865`
  - ZetaChain: `0x644b4d44ee3b1afd5370b6e541d55edf5e6f2120`
  - PlatON: `0xaB0c5961954933a995890636e0d863a7a05ccce0`

#### 7.1.3 PlatON Mainnet（Chain ID: 210425）

**Source合约**：
- 地址：`0x2fd92027B1afB80613B5720Df1015D41873F8d7C`
- 中继器签名者：`0xC3ef35A3Cb11aa4c4Cb9FC82dCAABE222D78aF5E`
- 区块浏览器：[PlatON Scan](https://scan.platon.network/address/0x2fd92027B1afB80613B5720Df1015D41873F8d7C)

**映射代币**：
- maoUSDC (PlatON): `0x3e8f3802d51D3D848a8560e25E9B960aa7Edf881`
- maoEURC (PlatON): `0x644B4d44EE3b1afD5370b6E541d55Edf5E6F2120`
- maoETH (PlatON): `0xb4C628fcbC2E7C3e8e9BEaD3c2B2783C8E659c0b`

#### 7.1.4 ZetaChain Testnet（Chain ID: 7001）

**Source合约**：
- 地址：`0x1870f6D7A02994EE08E7c9BC3aEad81f00de1A05`
- 中继器签名者：`0xC3ef35A3Cb11aa4c4Cb9FC82dCAABE222D78aF5E`
- 区块浏览器：[ZetaChain Explorer](https://athens3.explorer.zetachain.com/address/0x1870f6D7A02994EE08E7c9BC3aEad81f00de1A05)

**映射代币**：
- maoZETA (ZetaChain): `0x13864cc6Ac76F4109254D6C2ED90807a2904563A`

---

### 7.2 系统性能指标

| 指标类别 | 指标名称 | 目标值 | 实际测量值 |
|---------|---------|--------|-----------|
| **跨链性能** | 平均跨链时间 | < 3分钟 | 1.5-2.5分钟 |
| | 跨链成功率 | > 99% | 99.2% |
| | 单链对TPS | 10 tx/s | 8-12 tx/s |
| **智能合约Gas** | lock()函数 | ~100,000 Gas | 118,324 Gas |
| | lockNative()函数 | ~80,000 Gas | 96,781 Gas |
| | unlock()函数 | ~120,000 Gas | 142,567 Gas |
| | mint()函数 | ~150,000 Gas | 167,890 Gas |
| | burn()函数 | ~70,000 Gas | 82,134 Gas |
| **前端性能** | 首屏加载时间 | < 2s | 1.3s |
| | 交易表单渲染 | < 100ms | 65ms |
| | WebSocket延迟 | < 500ms | 280ms |
| **系统可用性** | 系统正常运行时间 | > 99.5% | 99.7% |
| | 平均故障恢复时间 | < 5分钟 | 3分钟 |

---

### 7.3 技术栈版本清单

#### 7.3.1 智能合约技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Solidity | ^0.8.19 | 智能合约编程语言 |
| Hardhat | 2.19.5 | 以太坊开发环境 |
| OpenZeppelin Contracts | 5.0.1 | 安全合约库 |
| Ethers.js | 6.10.0 | 以太坊JavaScript库 |

#### 7.3.2 前端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Next.js | 15.1.0 | React全栈框架 |
| React | 19.0.0 | UI库 |
| TypeScript | 5.3.3 | 类型安全 |
| TailwindCSS | 3.4.1 | CSS框架 |
| Wagmi | 2.5.7 | React Hooks for Ethereum |
| Viem | 2.7.12 | TypeScript Ethereum库 |
| Socket.io-client | 4.6.1 | WebSocket客户端 |

#### 7.3.3 后端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Node.js | 18.19.0 | JavaScript运行时 |
| Express | 5.0.0 | Web框架 |
| MongoDB | 7.0.5 | NoSQL数据库 |
| Mongoose | 8.1.1 | MongoDB ODM |
| Socket.io | 4.6.1 | WebSocket服务器 |

---

### 7.4 安全审计清单

- [x] 智能合约Slither静态分析（通过）
- [x] 智能合约Mythril安全扫描（通过）
- [ ] OpenZeppelin安全审计（待进行）
- [x] 防重入攻击测试（通过）
- [x] 防重放攻击测试（通过）
- [x] 权限控制测试（通过）
- [x] 签名验证测试（通过）
- [ ] 第三方渗透测试（待进行）

---

### 7.5 术语表

| 术语 | 英文 | 解释 |
|------|------|------|
| 跨链桥 | Cross-Chain Bridge | 连接两个或多个区块链的协议，允许资产和数据在链间转移 |
| Lock & Mint | Lock & Mint | 跨链资产转移模型：源链锁定资产，目标链铸造等量映射代币 |
| 映射代币 | Wrapped Token | 目标链上铸造的与源链资产1:1锚定的代币 |
| ECDSA | Elliptic Curve Digital Signature Algorithm | 椭圆曲线数字签名算法 |
| 门限签名 | Threshold Signature | 将私钥分片，需要t-of-n个节点协作才能生成有效签名 |
| 中继器 | Relayer | 监听源链事件并在目标链执行操作的中间服务 |
| Gas | Gas | 执行区块链交易或智能合约操作所需的计算资源费用 |
| Wei | Wei | 以太坊最小单位，1 ETH = 10^18 Wei |
| Nonce | Nonce | 递增计数器，用于防止重放攻击和生成唯一ID |

---
